export const fewShotExamples = [
  {
    className: 'Absolute',
    testcase:
      'public class Absolute {\n\t\n\tpublic  short Absolute(short num) {\n\t\tif (0 <= num)\n\t\t\treturn num;\n\t\telse\n\t\t\treturn (short)-num;\t\n\t}\n\n\t\n\tpublic  int Absolute(int num) {\n\t\tif (0 <= num)\n\t\t\treturn num;\n\t\telse\n\t\t\treturn -num;\n\t}\n\n\t\n\tpublic  long Absolute(long num) {\n\t\tif (0 <= num)\n\t\t\treturn num;\n\t\telse\n\t\t\treturn -num;\t\n\t}\n}',
    groundTruth:
      'public class Absolute {\n\t/*@    requires 0 <= num && num <= Short.MAX_VALUE;\n\t  @    ensures \\result == num;\n\t  @ also\n\t  @    requires  Short.MIN_VALUE < num && num < 0;\n\t  @    ensures \\result == -num; @*/\n\tpublic /*@ pure @*/ short Absolute(short num) {\n\t\tif (0 <= num)\n\t\t\treturn num;\n\t\telse\n\t\t\treturn (short)-num;\t\n\t}\n\n\t/*@    requires 0 <= num && num <= Integer.MAX_VALUE;\n\t  @    ensures \\result == num;\n\t  @ also\n\t  @    requires Integer.MIN_VALUE < num && num < 0;\n\t  @    ensures \\result == -num; @*/\n\tpublic /*@ pure @*/ int Absolute(int num) {\n\t\tif (0 <= num)\n\t\t\treturn num;\n\t\telse\n\t\t\treturn -num;\n\t}\n\n\t/*@    requires 0 <= num && num <= Long.MAX_VALUE;\n\t  @    ensures \\result == num;\n\t  @ also\n\t  @    requires  Long.MIN_VALUE < num && num < 0;\n\t  @    ensures \\result == -num; @*/\n\tpublic /*@ pure @*/ long Absolute(long num) {\n\t\tif (0 <= num)\n\t\t\treturn num;\n\t\telse\n\t\t\treturn -num;\t\n\t}\n}',
  },
  {
    className: 'AddLoop',
    testcase:
      'public class AddLoop {\n    \n    \n    public static int AddLoop(int x, int y) {\n        int sum = x;\n        if (y > 0) {\n            int n = y;\n            \n            \n            while (n > 0) {\n                sum = sum + 1;\n                n = n - 1;\n            }\n        } else {\n            int n = -y;\n            \n            \n            while (n > 0) {\n                sum = sum - 1;\n                n = n - 1;\n            }\n        }\n        return sum;\n    }\n}',
    groundTruth:
      'public class AddLoop {\n    //@ requires Integer.MIN_VALUE <= x + y && x + y <= Integer.MAX_VALUE && y != Integer.MIN_VALUE;\n    //@ ensures \\result == x + y;\n    public static int AddLoop(int x, int y) {\n        int sum = x;\n        if (y > 0) {\n            int n = y;\n            //@ decreases n;\n            //@ maintaining sum == x + y - n && 0 <= n;\n            while (n > 0) {\n                sum = sum + 1;\n                n = n - 1;\n            }\n        } else {\n            int n = -y;\n            //@ maintaining sum == x + y + n && 0 <= n;\n            //@ decreases n;\n            while (n > 0) {\n                sum = sum - 1;\n                n = n - 1;\n            }\n        }\n        return sum;\n    }\n}',
  },
  {
    className: 'Alphabet',
    testcase:
      "public class Alphabet {\n   private boolean vowel_set = false;\n   private boolean vowel;\n   \n\n   private boolean alphabetic_set = false;\n   private boolean alphabetic;\n   \n   private boolean digit_set = false;\n   private boolean digit;\n   \n   private boolean uppercase_set = false;\n   private boolean uppercase;\n   \n   private boolean lowercase_set = false;\n   private boolean lowercase;\n   \n\n   private  final char c;\n\n   \n   public  Alphabet(char c) \n   {\n\tthis.c = c;\n   }\n\n   \n   public boolean isVowel() \n   {\n       setVowel();\n       return vowel;\n   }\n\n   \n   public boolean isAlphabetic() \n   {\n\tsetAlphabetic();\n\treturn alphabetic;\n   }\n\n   \n   public boolean isUppercase() \n   {\n\tsetUppercase();\n\treturn uppercase;\n   }\n\n   \n   public boolean isLowercase() \n   {\n       setLowercase();\n       return lowercase;\n   }\n\n   \n   public boolean isDigit() \n   {\n\tsetDigit();\n\treturn digit;\n   }\n\n   \n   private  void setVowel() \n   {\n        vowel = false;\n        switch (c) {\n            case 'a' :\n            case 'e' :\n            case 'i' :\n            case 'o' :\n            case 'u' :\n            case 'A' :\n            case 'E' :\n            case 'I' :\n            case 'O' :\n            case 'U' : vowel = true;\n        }\n        vowel_set = true;\n   }\n\n   \n   private  void setAlphabetic() \n   {\n\talphabetic = (('a' <= c && c <= 'z')||('A' <= c && c <= 'Z'));\t\t\n\talphabetic_set = true;\n   }\n\n   \n   private  void setUppercase() \n   {\n\tuppercase = ('A' <= c && c <= 'Z');\t\t\n\tuppercase_set = true;\n   }\n\n   \n   private  void setLowercase() \n   {\n       lowercase = ('a' <= c && c <= 'z');\n       lowercase_set = true;\n   }\n\n   \n   private  void setDigit() \n   {\n\tdigit = ('0' <= c && c <= '9');\t\n\tdigit_set = true;\n   }\n\n   \n   public  boolean getAlphabetic_set()\n   {\n\treturn alphabetic_set;\n   }\n\n   \n   public  boolean getUppercase_set()\n   {\n\treturn uppercase_set;\n   }\n\n   \n   public  boolean getLowercase_set()\n   {\n\treturn lowercase_set;\n   }\n\n   \n   public  boolean getVowel_set()\n   {\n\treturn vowel_set;\n   }\n\n   \n   public  boolean getDigit_set()\n   {\n\treturn digit_set;\n   }\n   \n   \n   public boolean[] driver(int op) \n   {\n\tboolean[] result = new boolean[6];\n\tswitch (op) {\n\t\tcase 0 :\n\t\tresult[0] = isVowel();\n\t\tresult[1] = getVowel_set();\n\t\tbreak;\n\t\t\n\t\tcase 1 :\n\t\tresult[0] = isUppercase();\n\t\tresult[2] = getUppercase_set();\n\t\tbreak;\n\n\t\tcase 2 :\n\t\tresult[0] = isLowercase();\n\t\tresult[3] = getLowercase_set();\n\t\tbreak;\n\n\t\tcase 3 :\n\t\tresult[0] = isDigit();\n\t\tresult[4] = getDigit_set();\n\t\tbreak;\n\n\t\tdefault :\n\t\tresult[0] = isAlphabetic();\n\t\tresult[5] = getAlphabetic_set();\n\t\tbreak;\n\t}\n\treturn result;\n   }\n}",
    groundTruth:
      "public class Alphabet {\n   private boolean vowel_set = false;\n   private boolean vowel;\n   /*@ private invariant vowel_set ==> \n                     (vowel == (c == 'a' || c == 'A' || c == 'e' || c == 'E' \n                               || c == 'i' || c == 'I' || c == 'o'\n\t\t\t       || c == 'O' || c == 'u' || c == 'U')); @*/\n\n   private boolean alphabetic_set = false;\n   private boolean alphabetic;\n   //@ private invariant alphabetic_set ==> alphabetic == (('a' <= c && c <= 'z')||('A' <= c && c <='Z'));\n   private boolean digit_set = false;\n   private boolean digit;\n   //@ private invariant digit_set ==> digit == ('0' <= c && c <= '9');\n   private boolean uppercase_set = false;\n   private boolean uppercase;\n   //@ private invariant uppercase_set ==> (uppercase == ('A' <= c && c <= 'Z'));\n   private boolean lowercase_set = false;\n   private boolean lowercase;\n   //@ private invariant lowercase_set ==> (lowercase == ('a' <= c && c <= 'z'));\n\n   private /*@ spec_public @*/ final char c;\n\n   /*@ private normal_behavior\n     @   ensures !vowel_set && !alphabetic_set && !digit_set;\n     @   ensures !uppercase_set && !lowercase_set;\n     @ public normal_behavior\n     @   ensures this.c == c; @*/\n   public /*@ pure @*/ Alphabet(char c) \n   {\n\tthis.c = c;\n   }\n\n   /*@ private normal_behavior\n     @   assignable vowel_set, vowel;\n     @   ensures vowel_set && \\result == vowel;\n     @ public normal_behavior\n     @   \tensures \\result == (c == 'a' || c == 'A' || c == 'e' || c == 'E' \n     @    \t                      || c == 'i' || c == 'I' || c == 'o'\n     @\t\t\t\t      || c == 'O' || c == 'u' || c == 'U'); @*/\n   public boolean isVowel() \n   {\n       setVowel();\n       return vowel;\n   }\n\n   /*@ private normal_behavior\n     @   assignable alphabetic_set, alphabetic;\n     @   ensures alphabetic_set && \\result == alphabetic; \n     @ public normal_behavior\n     @   ensures \\result == ('a' <= c && c <= 'z')||('A' <= c && c <='Z'); @*/\n   public boolean isAlphabetic() \n   {\n\tsetAlphabetic();\n\treturn alphabetic;\n   }\n\n   /*@ private normal_behavior\n     @   assignable uppercase_set, uppercase;\n     @   ensures uppercase_set && \\result == uppercase; \n     @ public normal_behavior\n     @   ensures \\result == ('A' <= c && c <= 'Z'); @*/\n   public boolean isUppercase() \n   {\n\tsetUppercase();\n\treturn uppercase;\n   }\n\n   /*@ private normal_behavior\n      @   assignable lowercase_set, lowercase;\n      @   ensures lowercase_set && \\result == lowercase; \n      @ public normal_behavior\n      @   ensures \\result == ('a' <= c && c <= 'z'); @*/\n   public boolean isLowercase() \n   {\n       setLowercase();\n       return lowercase;\n   }\n\n   /*@ private normal_behavior\n     @   assignable digit_set, digit;\n     @   ensures digit_set && \\result == digit; \n     @ public normal_behavior\n     @   ensures \\result == ('0' <= c && c <= '9'); @*/\n   public boolean isDigit() \n   {\n\tsetDigit();\n\treturn digit;\n   }\n\n   /*@ private normal_behavior\n     @   assignable vowel_set, vowel;\n     @   ensures vowel_set;\n     @   ensures vowel <==> (c == 'a' || c == 'A' || c == 'e' || c == 'E' \n     @                     \t|| c == 'i' || c == 'I' || c == 'o'\n     @\t \t \t     \t|| c == 'O' || c == 'u' || c == 'U'); @*/\n   private /*@ spec_public @*/ void setVowel() \n   {\n        vowel = false;\n        switch (c) {\n            case 'a' :\n            case 'e' :\n            case 'i' :\n            case 'o' :\n            case 'u' :\n            case 'A' :\n            case 'E' :\n            case 'I' :\n            case 'O' :\n            case 'U' : vowel = true;\n        }\n        vowel_set = true;\n   }\n\n   /*@ private normal_behavior\n     @    assignable alphabetic_set, alphabetic;\n     @    ensures alphabetic_set;\n     @    ensures alphabetic <==> ('a' <= c && c <= 'z')||('A' <= c && c <= 'Z'); @*/\n   private /*@ spec_public @*/ void setAlphabetic() \n   {\n\talphabetic = (('a' <= c && c <= 'z')||('A' <= c && c <= 'Z'));\t\t\n\talphabetic_set = true;\n   }\n\n   /*@ private normal_behavior\n     @    assignable uppercase_set, uppercase;\n     @    ensures uppercase_set;\n     @    ensures uppercase <==> ('A' <= c && c <= 'Z'); @*/\n   private /*@ spec_public @*/ void setUppercase() \n   {\n\tuppercase = ('A' <= c && c <= 'Z');\t\t\n\tuppercase_set = true;\n   }\n\n   /*@ private normal_behavior\n     @    assignable lowercase_set, lowercase;\n     @    ensures lowercase_set;\n     @    ensures lowercase <==> ('a' <= c && c <= 'z'); @*/\n   private /*@ spec_public @*/ void setLowercase() \n   {\n       lowercase = ('a' <= c && c <= 'z');\n       lowercase_set = true;\n   }\n\n   /*@ private normal_behavior\n     @    assignable digit_set, digit;\n     @    ensures digit_set;\n     @    ensures digit <==> ('0' <= c && c <= '9'); @*/\n   private /*@ spec_public @*/ void setDigit() \n   {\n\tdigit = ('0' <= c && c <= '9');\t\n\tdigit_set = true;\n   }\n\n   /*@ private normal_behavior\n     @   ensures \\result == alphabetic_set; @*/\n   public /*@ pure @*/ boolean getAlphabetic_set()\n   {\n\treturn alphabetic_set;\n   }\n\n   /*@ private normal_behavior\n     @   ensures \\result == uppercase_set; @*/\n   public /*@ pure @*/ boolean getUppercase_set()\n   {\n\treturn uppercase_set;\n   }\n\n   /*@ private normal_behavior\n     @   ensures \\result == lowercase_set; @*/\n   public /*@ pure @*/ boolean getLowercase_set()\n   {\n\treturn lowercase_set;\n   }\n\n   /*@ private normal_behavior\n     @   ensures \\result == vowel_set; @*/\n   public /*@ pure @*/ boolean getVowel_set()\n   {\n\treturn vowel_set;\n   }\n\n   /*@ private normal_behavior\n     @   ensures \\result == digit_set; @*/\n   public /*@ pure @*/ boolean getDigit_set()\n   {\n\treturn digit_set;\n   }\n   \n   /*@ requires 0 <= op && op <= 4;\n     @ {|\n     @      requires op == 0;\n     @      ensures \\result[0] ==> (c == 'a' || c == 'A' || c == 'e' || c == 'E' || c == 'i' || c == 'I' || c == 'o' ||\n     @\t\t \t         c == 'O' || c == 'u' || c == 'U'); \n     @\t    ensures \\result[1];\n     @ also\n     @      requires op == 1;\n     @      ensures \\result[0] ==> ('A' <= c && c <= 'Z');\n     @\t    ensures \\result[2];\n     @ also\n     @      requires op == 2;\n     @      ensures \\result[0] ==> ('a' <= c && c <= 'z');\n     @\t    ensures \\result[3];\n     @ also\n     @      requires op == 3;\n     @      ensures \\result[0] ==> ('0' <= c && c <= '9');\n     @\t    ensures \\result[4];\n     @ also\n     @      requires op == 4;\n     @\t    ensures \\result[5];\n     @ |} @*/\n   public boolean[] driver(int op) \n   {\n\tboolean[] result = new boolean[6];\n\tswitch (op) {\n\t\tcase 0 :\n\t\tresult[0] = isVowel();\n\t\tresult[1] = getVowel_set();\n\t\tbreak;\n\t\t\n\t\tcase 1 :\n\t\tresult[0] = isUppercase();\n\t\tresult[2] = getUppercase_set();\n\t\tbreak;\n\n\t\tcase 2 :\n\t\tresult[0] = isLowercase();\n\t\tresult[3] = getLowercase_set();\n\t\tbreak;\n\n\t\tcase 3 :\n\t\tresult[0] = isDigit();\n\t\tresult[4] = getDigit_set();\n\t\tbreak;\n\n\t\tdefault :\n\t\tresult[0] = isAlphabetic();\n\t\tresult[5] = getAlphabetic_set();\n\t\tbreak;\n\t}\n\treturn result;\n   }\n}",
  },
  {
    className: 'BankAccount',
    testcase:
      'public class BankAccount \n{\n\tint balance;\n\tint previousTransaction;\n        \n\tBankAccount()\n\t{\n\t\tbalance = 0;\n\t\tpreviousTransaction = 0;\n\t}\n\n\tBankAccount(int currentBalance)\n\t{\n\t\tif (currentBalance <= 0){\n\t\t\tbalance = 0;\n\t\t} else {\t\t\n\t\t\tbalance = currentBalance;\n\t\t}\n\t\tpreviousTransaction = 0;\n\t}\n\t\n\tBankAccount(int currentBalance, int _previousTransaction)\n\t{\n\t\tif (currentBalance <= 0){\n\t\t\tbalance = 0;\n\t\t} else {\t\t\n\t\t\tbalance = currentBalance;\n\t\t}\n\t\tpreviousTransaction = _previousTransaction;\n\t}\n\n\tint getBalance() \n\t{\n\t\treturn this.balance;\n\t}\n\n\tint getPreviousTransaction()\n\t{\n\t\treturn this.previousTransaction;\n\t}\n\n\tboolean isValid(int _amount)\n\t{\n\t\tif (0 < _amount) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\t boolean isValid(int _balance, int _amount)\n\t{\n\t\tif (0 <= _balance - _amount) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tvoid deposit(int amount)\n\t{\n\t\tif (isValid(amount)) {\n\t\t\tbalance = balance + amount;\n\t\t\tpreviousTransaction = amount;\n\t\t} \n\t}\n\t\n\tvoid withdraw(int amount)\n\t{\n\t\tif (isValid(amount)) {\n\t\t\tif (isValid(balance, amount)) {\n\t\t\t\tbalance = balance - amount;\n\t\t\t\tpreviousTransaction = -amount;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid checkWithdrawal(int amount)\n\t{\n\t\tif (isValid(amount)) {\n\t\t\tif (isValid(balance, amount)) {\n\t\t\t\tbalance = balance - amount;\n\t\t\t\tpreviousTransaction = -amount;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint notEnoughMoneyPenalty;\n\t\t\t\tnotEnoughMoneyPenalty = 50;\n\t\t\t\tint _balance;\n\t\t\t\t_balance = balance - notEnoughMoneyPenalty;\n\t\t\t\tif (0 <= _balance) { \n\t\t\t\t\tbalance = _balance;\n\t\t\t\t\tpreviousTransaction = -notEnoughMoneyPenalty;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpreviousTransaction = -balance;\n\t\t\t\t\tbalance = 0;\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid foreignTransfer(int amount)\n\t{\n\t\tint penalty;\n\t\tpenalty = (amount/100)*5;\n\t\tamount = amount + penalty;\n\t\tif (isValid(amount)) {\n\t\t\tif (isValid(balance, amount)) {\n\t\t\t\tbalance = balance - amount;\n\t\t\t\tpreviousTransaction = -amount;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid foreignDeposit(int amount) \n\t{\n\t\tint penalty;\n\t\tpenalty = (amount/100)*5;\n\t\tamount = amount - penalty;\n\t\tif (isValid(amount)) {\n\t\t\tbalance = balance + amount;\n\t\t\tpreviousTransaction = amount;\n\t\t}\n\t}\n\n\tvoid withdrawByCashBack(int amount) \n\t{\n\t\tint cashback; \n\t\tcashback =  (amount/100)*2;\n\t\tamount = amount - cashback;\n\t\tif (isValid(amount)) {\n\t\t\tif (isValid(balance, amount)) {\n\t\t\t\tbalance = balance - amount;\n\t\t\t\tpreviousTransaction = -amount;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid ATMWithdraw(int amount)\n\t{\n\t\tint ATMpenalty = 4;\n\t\tif (isValid(amount)) {\n\t\t\tamount += ATMpenalty;\n\t\t\tif (isValid(balance, amount)) {\n\t\t\t\tbalance = balance - amount;\n\t\t\t\tpreviousTransaction = -amount;\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\n\tint interestAfterYear () \n\t{\n\t\tint interest;\n\t\tinterest = 0;\n\t\tif (balance <= 20000) {\n\t\t\tinterest = balance/100;\n\t\t} \n\t\telse if (balance <= 160000) { \n\t\t\tint _interest;\n\t\t\t_interest = balance/100;\n\t\t\tinterest = _interest*2;\n\t\t}\n\t\telse if (balance <= 300000) {\n\t\t\tint _interest;\n\t\t\t_interest = balance/100;\n\t\t\tinterest = _interest*3;\n\t\t}\n\t\telse {\n\t\t\tint _interest;\n\t\t\t_interest = balance/100;\n\t\t\tinterest = _interest*4;\n\t\t}\n\t\treturn interest;\n\t}\n\n\t \n\tint menu(int option, int amount)\n\t{\n\t\tint result;\n\t\tresult = 0;\t\n\t\t\t\n\t\tswitch (option) \n\t\t{\n\t\t\tcase 1:\n\t\t\tdeposit(amount);\n\t\t\tresult = getBalance();\n\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\twithdraw(amount);\n\t\t\tresult = getBalance();\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 3: \n\t\t\tcheckWithdrawal(amount);\n\t\t\tresult = getBalance();\n\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\tresult = getPreviousTransaction();\n\t\t\tbreak;\n\n\t\t\tcase 5: \n\t\t\tforeignTransfer(amount);\n\t\t\tresult = getBalance();\n\t\t\tbreak;\n\n\t\t\tcase 6:\n\t\t\twithdrawByCashBack(amount); \n\t \t\tresult = getBalance();\n\t\t\tbreak;\n\n\t\t\tcase 7: \n\t\t\tforeignDeposit(amount);\n\t\t\tresult = getBalance();\n\t\t\tbreak;\n\n\t\t\tcase 8:\n\t\t\tresult = interestAfterYear();\n\t\t\tbreak;\n\n\t\t\tcase 9:\n\t\t\tATMWithdraw(amount);\n\t\t\tresult = getBalance();\n\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\tresult = getBalance();\n               \t\tbreak;\n\t\t}\n\t        return result;\n        }\n}',
    groundTruth:
      'public class BankAccount \n{\n\tint balance;\n\tint previousTransaction;\n        //@ invariant 0 <= balance;\n\n\t//@ assignable \\everything;\n\t//@ ensures balance == 0; \n\t//@ ensures previousTransaction == 0; \n\tBankAccount()\n\t{\n\t\tbalance = 0;\n\t\tpreviousTransaction = 0;\n\t}\n\n\t//@ assignable \\everything; \n\t//@ ensures (currentBalance <= 0) ==> balance == 0; \n\t//@ ensures (0 < currentBalance) ==> balance == currentBalance; \n\t//@ ensures previousTransaction == 0; \n\tBankAccount(int currentBalance)\n\t{\n\t\tif (currentBalance <= 0){\n\t\t\tbalance = 0;\n\t\t} else {\t\t\n\t\t\tbalance = currentBalance;\n\t\t}\n\t\tpreviousTransaction = 0;\n\t}\n\n\t//@ assignable \\everything;\n\t//@ ensures (currentBalance <= 0) ==> balance == 0; \n\t//@ ensures (0 < currentBalance) ==> balance == currentBalance; \n\t//@ ensures previousTransaction == _previousTransaction; \n\tBankAccount(int currentBalance, int _previousTransaction)\n\t{\n\t\tif (currentBalance <= 0){\n\t\t\tbalance = 0;\n\t\t} else {\t\t\n\t\t\tbalance = currentBalance;\n\t\t}\n\t\tpreviousTransaction = _previousTransaction;\n\t}\n\n\t//@ ensures \\result == this.balance;\n\t/*@ spec_public pure @*/ int getBalance() \n\t{\n\t\treturn this.balance;\n\t}\n\n\t//@ ensures \\result == this.previousTransaction;\n\t/*@ spec_public pure @*/ int getPreviousTransaction()\n\t{\n\t\treturn this.previousTransaction;\n\t}\n\t\n\t//@ requires 0 < _amount;\n\t//@ ensures \\result;\n\t\n\t//@ also\n\n\t//@ requires _amount <= 0;\n\t//@ ensures !\\result;\n\t/*@ spec_public pure @*/  boolean isValid(int _amount)\n\t{\n\t\tif (0 < _amount) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t//@ requires isValid(_amount);\n\t//@ requires 0 <= _balance;\n\t//@ {|\t\n\t  //@ requires 0 <= _balance - _amount;\n\t  //@ ensures \\result;\n\t\n\t  //@ also\n\n\t  //@ requires _balance - _amount < 0;\n\t  //@ ensures !\\result;\n\t//@ |}\n\t/*@ spec_public pure @*/ boolean isValid(int _balance, int _amount)\n\t{\n\t\tif (0 <= _balance - _amount) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t//@ requires isValid(amount);\n\t//@ requires amount + balance <= Integer.MAX_VALUE;\n\t//@ assignable balance, previousTransaction;\n\t//@ ensures balance == \\old (balance) + amount;\n\t//@ ensures previousTransaction == amount;\n\n\t//@ also\n\n\t//@ requires !isValid(amount);\n\t//@ ensures balance == \\old (balance);\n\t//@ ensures previousTransaction == \\old (previousTransaction);\n\tvoid deposit(int amount)\n\t{\n\t\tif (isValid(amount)) {\n\t\t\tbalance = balance + amount;\n\t\t\tpreviousTransaction = amount;\n\t\t} \n\t}\n\n\t//@ requires isValid(amount);\n\t//@ requires isValid(balance, amount);\n\t//@ assignable balance, previousTransaction;\n\t//@ ensures balance == \\old (balance) - amount;\n\t//@ ensures previousTransaction == -amount;\n\t  \n\t//@ also\n\n\t//@ requires isValid(amount);\n\t//@ requires !isValid(balance, amount);\n\t//@ ensures balance == \\old (balance);\n\t//@ ensures previousTransaction == \\old (previousTransaction);\n\n\t//@ also\n\n\t//@ requires !isValid(amount);\n\t//@ ensures balance == \\old (balance);\n\t//@ ensures previousTransaction == \\old (previousTransaction);\n\tvoid withdraw(int amount)\n\t{\n\t\tif (isValid(amount)) {\n\t\t\tif (isValid(balance, amount)) {\n\t\t\t\tbalance = balance - amount;\n\t\t\t\tpreviousTransaction = -amount;\n\t\t\t}\n\t\t}\n\t}\n\n\t//@ requires isValid(amount);\n\t//@ requires isValid(balance, amount);\n\t//@ assignable balance, previousTransaction;\n\t//@ ensures balance == \\old (balance) - amount;\n\t//@ ensures previousTransaction == -amount;\n\t  \n\t//@ also\n\n\t//@ requires isValid(amount);\n\t//@ requires !isValid(balance, amount);\n\t//@ requires isValid(balance, 50);  \n\t//@ assignable balance, previousTransaction;\n\t//@ ensures balance == \\old (balance) - 50;\n\t//@ ensures previousTransaction == -50;\n\t\n\t//@ also\n\n\t//@ requires isValid(amount);\n\t//@ requires !isValid(balance, amount);\n\t//@ requires !isValid(balance, 50); \n\t//@ assignable balance, previousTransaction;\n\t//@ ensures balance == 0;\n\t//@ ensures previousTransaction == \\old (-balance);\n\n\t//@ also\n\n\t//@ requires !isValid(amount);\n\t//@ ensures balance == \\old (balance);\n\t//@ ensures previousTransaction == \\old (previousTransaction);\n\tvoid checkWithdrawal(int amount)\n\t{\n\t\tif (isValid(amount)) {\n\t\t\tif (isValid(balance, amount)) {\n\t\t\t\tbalance = balance - amount;\n\t\t\t\tpreviousTransaction = -amount;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint notEnoughMoneyPenalty;\n\t\t\t\tnotEnoughMoneyPenalty = 50;\n\t\t\t\tint _balance;\n\t\t\t\t_balance = balance - notEnoughMoneyPenalty;\n\t\t\t\tif (0 <= _balance) { \n\t\t\t\t\tbalance = _balance;\n\t\t\t\t\tpreviousTransaction = -notEnoughMoneyPenalty;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpreviousTransaction = -balance;\n\t\t\t\t\tbalance = 0;\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t}\n\n\t//@ old int _amount =  amount + (amount/100)*5;\n\t//@ requires _amount <= Integer.MAX_VALUE;\n\t//@ {|\t\n\t  //@ requires isValid(_amount);\n\t  //@ requires isValid(balance, _amount);\n\t  //@ assignable balance, previousTransaction;\n\t  //@ ensures balance == \\old (balance) - _amount;\n\t  //@ ensures previousTransaction == -_amount;\n\t  \n\t  //@ also \n\n\t  //@ requires isValid(_amount);\n\t  //@ requires !isValid(balance, _amount);\n   \t  //@ ensures balance == \\old (balance);\n\t  //@ ensures previousTransaction == \\old (previousTransaction);\n\n\t  //@ also\n\n\t  //@ requires !isValid(_amount);\n\t  //@ ensures balance == \\old (balance);\n\t  //@ ensures previousTransaction == \\old (previousTransaction);\n\t//@ |}\n\tvoid foreignTransfer(int amount)\n\t{\n\t\tint penalty;\n\t\tpenalty = (amount/100)*5;\n\t\tamount = amount + penalty;\n\t\tif (isValid(amount)) {\n\t\t\tif (isValid(balance, amount)) {\n\t\t\t\tbalance = balance - amount;\n\t\t\t\tpreviousTransaction = -amount;\n\t\t\t}\n\t\t}\n\t}\n\n\t//@ old int _amount = amount - (amount/100)*5;\n\t//@ requires isValid(_amount);\n\t//@ requires _amount + balance <= Integer.MAX_VALUE;\n\t//@ assignable balance, previousTransaction;\n\t//@ ensures balance == \\old (balance) + _amount;\n\t//@ ensures previousTransaction == _amount;\n\n\t//@ also\n\n\t//@ old int _amount = amount - (amount/100)*5;\n\t//@ requires !isValid(_amount);\n\t//@ ensures balance == \\old (balance);\n\t//@ ensures previousTransaction == \\old (previousTransaction);\n\tvoid foreignDeposit(int amount) \n\t{\n\t\tint penalty;\n\t\tpenalty = (amount/100)*5;\n\t\tamount = amount - penalty;\n\t\tif (isValid(amount)) {\n\t\t\tbalance = balance + amount;\n\t\t\tpreviousTransaction = amount;\n\t\t}\n\t}\n\n\t//@ old int _amount = amount - (amount/100)*2;\n\t//@ requires isValid(_amount);\n\t//@ requires isValid(balance, _amount);\n\t//@ assignable balance, previousTransaction;\n\t//@ ensures balance == \\old (balance) - _amount;\n\t//@ ensures previousTransaction == -_amount;\n\t  \n\t//@ also\n\n\t//@ old int _amount =  amount - (amount/100)*2;\n\t//@ requires isValid(_amount);\n\t//@ requires !isValid(balance, _amount); \n\t//@ ensures balance == \\old (balance);\n\t//@ ensures previousTransaction == \\old (previousTransaction);\n\n\t//@ also\n\n\t//@ old int _amount =  amount - (amount/100)*2;\n\t//@ requires !isValid(_amount);\n\t//@ ensures balance == \\old (balance);\n\t//@ ensures previousTransaction == \\old (previousTransaction);\n\tvoid withdrawByCashBack(int amount) \n\t{\n\t\tint cashback; \n\t\tcashback =  (amount/100)*2;\n\t\tamount = amount - cashback;\n\t\tif (isValid(amount)) {\n\t\t\tif (isValid(balance, amount)) {\n\t\t\t\tbalance = balance - amount;\n\t\t\t\tpreviousTransaction = -amount;\n\t\t\t}\n\t\t}\n\t}\n\t//@ old int ATMpenalty = 4;\n\t//@ requires amount + ATMpenalty <= Integer.MAX_VALUE;\n\t//@ {|\n\t  //@ requires isValid(amount);\n\t  //@ requires isValid(balance, (amount + ATMpenalty));\n\t  //@ assignable balance, previousTransaction;\n\t  //@ ensures balance == \\old (balance) - (amount + ATMpenalty);\n\t  //@ ensures previousTransaction == -(amount + ATMpenalty);\n\n\t  //@ also \n\n\t  //@ requires isValid(amount);\n\t  //@ requires !isValid(balance, (amount + ATMpenalty));\n\t  //@ ensures balance == \\old (balance);\n\t  //@ ensures previousTransaction == \\old (previousTransaction);\n\n\t  //@ also\n\n\t  //@ requires !isValid(amount);\n\t  //@ ensures balance == \\old (balance);\n\t  //@ ensures previousTransaction == \\old (previousTransaction);\n\t//@ |}\n\tvoid ATMWithdraw(int amount)\n\t{\n\t\tint ATMpenalty = 4;\n\t\tif (isValid(amount)) {\n\t\t\tamount += ATMpenalty;\n\t\t\tif (isValid(balance, amount)) {\n\t\t\t\tbalance = balance - amount;\n\t\t\t\tpreviousTransaction = -amount;\n\t\t\t}\n\t\t}\n\t}\n\t\t\n\t//@ requires balance <= 20000;\n\t//@ ensures \\result == balance/100;\n\n\t//@ also\n\n\t//@ requires 20000 < balance && balance <= 160000;\n\t//@ ensures \\result == (balance/100)*2;\n\n\t//@ also\n\n\t//@ requires 160000 < balance && balance <= 300000 ;\n\t//@ ensures \\result == (balance/100)*3;\n\n\t//@ also\n\n\t//@ requires 300000 < balance && balance <= Integer.MAX_VALUE;\n\t//@ ensures \\result == (balance/100)*4;\n\t/*@ spec_public pure @*/int interestAfterYear () \n\t{\n\t\tint interest;\n\t\tinterest = 0;\n\t\tif (balance <= 20000) {\n\t\t\tinterest = balance/100;\n\t\t} \n\t\telse if (balance <= 160000) { \n\t\t\tint _interest;\n\t\t\t_interest = balance/100;\n\t\t\tinterest = _interest*2;\n\t\t}\n\t\telse if (balance <= 300000) {\n\t\t\tint _interest;\n\t\t\t_interest = balance/100;\n\t\t\tinterest = _interest*3;\n\t\t}\n\t\telse {\n\t\t\tint _interest;\n\t\t\t_interest = balance/100;\n\t\t\tinterest = _interest*4;\n\t\t}\n\t\treturn interest;\n\t}\n\n\t/*@ assignable \\everything;\n\t    requires 0 <= option && option <= 9; \n\t    {|\n\t\trequires option == 1 && isValid(amount);\n\t  \trequires amount + balance <= Integer.MAX_VALUE;\n\t  \tensures balance == \\old (balance) + amount;\n\t  \tensures previousTransaction == amount;\n\t\t\n\t \talso\n\n\t   \trequires option == 2 && isValid(amount);\n\t   \trequires isValid(balance, amount);\n\t   \tensures balance == \\old (balance) - amount;\n\t \tensures \\result == balance;\n\t   \tensures previousTransaction == -amount;\n\n\t \talso\n\n\t \trequires option == 3 && isValid(amount);\n\t   \trequires isValid(balance, amount);\n\t   \tensures balance == \\old (balance) - amount;\n\t   \tensures previousTransaction == -amount;\n\n\t   \talso\n\n\t   \trequires option == 3 && isValid(amount);\n\t   \trequires !isValid(balance, amount);\n\t   \trequires isValid(balance, 50);  \n\t   \tensures balance == \\old (balance) - 50;\n\t   \tensures previousTransaction == -50;\n\t\n\t   \talso\n\n\t   \trequires option == 3 && isValid(amount);\n\t   \trequires !isValid(balance, amount);\n\t   \trequires !isValid(balance, 50); \n\t   \tensures balance == 0;\n\t   \tensures previousTransaction == \\old (-balance);\n\n\t\talso \n\n\t \trequires option == 4;\n\t \tensures \\result == previousTransaction;\n\n\t \talso\n\t\t\n\t \told int _amount =  amount + (amount/100)*5;\n\t \trequires option == 5;\n\t\trequires _amount <= Integer.MAX_VALUE;\n\t   \trequires isValid(_amount);\n\t   \trequires isValid(balance, _amount);\n\t   \tensures balance == \\old (balance) - _amount;\n\t   \tensures previousTransaction == -_amount;\n\n\t   \talso\n\t\n\t   \told int _amount =  amount + (amount/100)*5;\n\t \trequires option == 5;\n\t\trequires _amount <= Integer.MAX_VALUE;\n\t   \trequires isValid(_amount);\n\t   \trequires !isValid(balance, _amount);\n\t   \tensures balance == \\old (balance);\n\t        ensures previousTransaction == \\old (previousTransaction);  \n\n\t \talso\n\n\t \told int _amount =  amount - (amount/100)*2;\n\t   \trequires option == 6 && isValid(_amount);\n\t   \trequires isValid(balance, _amount);\n\t   \tensures balance == \\old (balance) - _amount;\n\t   \tensures previousTransaction == -_amount;\n\n\t   \talso\n\n\t  \told int _amount =  amount - (amount/100)*2;\n\t   \trequires option == 6 && isValid(_amount);\n\t   \trequires !isValid(balance, _amount);\n\t\tensures balance == \\old (balance);\n\t\tensures previousTransaction == \\old (previousTransaction);  \n\n\t \talso\n\n\t\told int _amount =  amount - (amount/100)*5;\n\t \trequires option == 7 && isValid(_amount);\n\t   \trequires _amount + balance <= Integer.MAX_VALUE;\n\t   \tensures balance == \\old (balance) + _amount;\n\t   \tensures previousTransaction == _amount;\n\t\t\n\t \talso\n\n\t   \trequires option == 8 && balance <= 20000;\n\t   \tensures \\result == balance/100;\n\n\t   \talso\n\n\t   \trequires option == 8 && 20000 < balance && balance <= 160000;\n\t   \tensures \\result == (balance/100)*2;\n\n\t   \talso\n\n\t   \trequires option == 8 && 160000 < balance && balance <= 300000 ;\n\t   \tensures \\result == (balance/100)*3;\n\n\t   \talso\n\n\t   \trequires option == 8 && 300000 < balance && balance <= Integer.MAX_VALUE;\n\t   \tensures \\result == (balance/100)*4;\n\n\t\talso\n\n\t\trequires option == 9;\n\t\told int ATMpenalty = 4;\n\t\trequires amount + ATMpenalty <= Integer.MAX_VALUE;\n\t\trequires isValid(amount);\n\t\trequires isValid(balance, (amount + ATMpenalty));\n\t\tensures balance == \\old (balance) - (amount + ATMpenalty);\n\t\tensures previousTransaction == -(amount + ATMpenalty);\n\t \n               also\n\n\t       requires option == 0;\n               ensures balance == \\old (balance);\n\t       ensures previousTransaction == \\old (previousTransaction);\n\t    |} @*/ \n\tint menu(int option, int amount)\n\t{\n\t\tint result;\n\t\tresult = 0;\t\n\t\t\t\n\t\tswitch (option) \n\t\t{\n\t\t\tcase 1:\n\t\t\tdeposit(amount);\n\t\t\tresult = getBalance();\n\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\twithdraw(amount);\n\t\t\tresult = getBalance();\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 3: \n\t\t\tcheckWithdrawal(amount);\n\t\t\tresult = getBalance();\n\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\tresult = getPreviousTransaction();\n\t\t\tbreak;\n\n\t\t\tcase 5: \n\t\t\tforeignTransfer(amount);\n\t\t\tresult = getBalance();\n\t\t\tbreak;\n\n\t\t\tcase 6:\n\t\t\twithdrawByCashBack(amount); \n\t \t\tresult = getBalance();\n\t\t\tbreak;\n\n\t\t\tcase 7: \n\t\t\tforeignDeposit(amount);\n\t\t\tresult = getBalance();\n\t\t\tbreak;\n\n\t\t\tcase 8:\n\t\t\tresult = interestAfterYear();\n\t\t\tbreak;\n\n\t\t\tcase 9:\n\t\t\tATMWithdraw(amount);\n\t\t\tresult = getBalance();\n\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\tresult = getBalance();\n               \t\tbreak;\n\t\t}\n\t        return result;\n        }\n}',
  },
  {
    className: 'BinarySearch',
    testcase:
      'public class BinarySearch {\n\n    public static int Binary(int[] arr, int key) {\n        if (arr.length == 0) {\n            return -1;\n        } else {\n            int low = 0;\n            int high = arr.length;\n            int mid =  high / 2;\n\n            while (low < high && arr[mid] != key) {\n                if (arr[mid] < key) {\n                    low = mid + 1;\n                } else {\n                    high = mid;\n                }\n                mid = low + (high - low) / 2;\n            }\n            if (low >= high) {\n                return -1;\n            }\n            return mid;\n        }\n    }\n}',
    groundTruth:
      'public class BinarySearch {\n    //@ requires \\forall int j; 0 <= j && j < arr.length; \\forall int i; 0 <= i && i < j ;arr[i] <= arr[j];\n    //@ ensures \\result == -1 <==> (\\forall int i; 0 <= i && i < arr.length; arr[i] != key) || arr.length == 0;\n    //@ ensures 0 <= \\result && \\result < arr.length ==> arr[\\result] == key;\n    public static int Binary(int[] arr, int key) {\n        if (arr.length == 0) {\n            return -1;\n        } else {\n            int low = 0;\n            int high = arr.length;\n            int mid =  high / 2;\n            //@ maintaining 0 <= low && low <= high  && high <= arr.length && mid == low + (high - low) / 2;\n            //@ maintaining (\\forall int i; 0 <= i && i < low; arr[i] < key);\n            //@ maintaining (\\forall int i; high <= i && i < arr.length; key < arr[i]);\n            //@ decreases high - low;\n            while (low < high && arr[mid] != key) {\n                if (arr[mid] < key) {\n                    low = mid + 1;\n                } else {\n                    high = mid;\n                }\n                mid = low + (high - low) / 2;\n            }\n            if (low >= high) {\n                return -1;\n            }\n            return mid;\n        }\n    }\n}',
  },
  {
    className: 'BubbleSort',
    testcase:
      'public class BubbleSort { \n    \n    int[] bubbleSort(int arr[]) { \n\tSwapInArray s = new SwapInArray();\n        int n = arr.length;\n\n        for (int i = 0; i < n-1; i++) {\t\n\n            for (int j = 0; j < n-i-1; j++) {\n                if (arr[j+1] < arr[j]) {  \n\t\t            s.swap(j, j + 1, arr); \n                } \n\t        }\n\t    } \n\t    return arr;\n    } \n}',
    groundTruth:
      'public class BubbleSort { \n    //@ requires 0 < arr.length;\n    //@ ensures \\forall int i; 0 <= i && i < \\result.length; \\forall int j; i <= j && j < \\result.length; \\result[i] <= \\result[j];\n    int[] bubbleSort(int arr[]) { \n\tSwapInArray s = new SwapInArray();\n        int n = arr.length;\n\t\n\t//@ maintaining n == arr.length;\n\t//@ maintaining 0 <= i && i < n; \n\t//@ maintaining 0 < i ==> (\\forall int k; 0 <= k && k < n-i; arr[k] <= arr[n-i]);\n\t//@ maintaining  (\\forall int t; n-i <= t && t < n; arr[n-i] <= arr[t]);\n\t//@ maintaining 0 < i ==> (\\forall int h; n-i <= h && h < n; (\\forall int p; n-i <= p && p < n && p <= h; arr[p] <= arr[h]));\n \t//@ decreases n - i;\n        for (int i = 0; i < n-1; i++) {\t\n\t    //@ maintaining 0 <= i && i < n - 1;\n\t    //@ maintaining 0 <= j && j < n - i;\n\t    //@ maintaining 0 < j ==> arr[j-1] <= arr[j];\n\t    //@ maintaining (\\forall int k; 0 <= k && k < j; arr[k] <= arr[j]);\n\t    //@ maintaining 0 < j  && j < n - i ==> (\\forall int t; n-i <= t && t < n; arr[j] <= arr[t]);\n\t    //@ decreases n - j;\n            for (int j = 0; j < n-i-1; j++) {\n                if (arr[j+1] < arr[j]) {  \n\t\t    s.swap(j, j + 1, arr); \n                } \n\t    }\n\t} \n\treturn arr;\n    } \n}',
  },
  {
    className: 'Calculator',
    testcase:
      "public class Calculator {\n    \n    public  int calculate(int num1, int num2, char operator) {\n\n        int output;\n\n        switch (operator)\n        {\n            case '+':\n            \toutput = num1 + num2;\n                break;\n\n            case '-':\n            \toutput = num1 - num2;\n                break;\n\n            case '*':\n            \toutput = num1 * num2;\n                break;\n\n            case '/':\n            \toutput = num1 / num2;\n\t\tbreak;\n\n\t    case '%':\n\t\toutput = num1 % num2;\n                break;\n\n            default:\n                return -1;\n        }\n        return output;\n    }\n}",
    groundTruth:
      "public class Calculator {\n    /*@ requires 37 <= (int)operator && (int)operator <= 47;\n      @ {|\n      @    requires operator == '+';\n      @    requires num1 + num2 <= Integer.MAX_VALUE;\n      @    requires Integer.MIN_VALUE <= num1 + num2;\n      @    ensures \\result == num1 + num2;\n      @ also\n      @    requires operator == '*'; \n      @    requires num1 * num2 <= Integer.MAX_VALUE;\n      @    requires Integer.MIN_VALUE <= num1 * num2;\n      @    ensures \\result == num1 * num2;\n      @ also\n      @    requires operator == '-'; \n      @    requires num1 - num2 <= Integer.MAX_VALUE;\n      @    requires Integer.MIN_VALUE <= num1 - num2;\n      @    ensures \\result == num1 - num2;\n      @ also\n      @    requires operator == '/'; \n      @    requires num2 != 0;\n      @    requires num1 / num2 <= Integer.MAX_VALUE;\n      @    requires num1 / num2 != Integer.MIN_VALUE;\n      @    ensures \\result == (num1 / num2);\n      @ also\n      @    requires operator == '%'; \n      @    requires num2 != 0;\n      @    requires num1 % num2 != Integer.MIN_VALUE;\n      @    ensures \\result == (num1 % num2);\n      @ also\n      @    requires operator != '+' && operator != '*' && operator != '-' && operator != '/' && operator != '%';\n      @    ensures \\result == -1;\n    |} @*/\n    public /*@ pure @*/ int calculate(int num1, int num2, char operator) {\n\n        int output;\n\n        switch (operator)\n        {\n            case '+':\n            \toutput = num1 + num2;\n                break;\n\n            case '-':\n            \toutput = num1 - num2;\n                break;\n\n            case '*':\n            \toutput = num1 * num2;\n                break;\n\n            case '/':\n            \toutput = num1 / num2;\n\t\tbreak;\n\n\t    case '%':\n\t\toutput = num1 % num2;\n                break;\n\n            default:\n                return -1;\n        }\n        return output;\n    }\n}",
  },
  {
    className: 'CombinationPermutation',
    testcase:
      'public class CombinationPermutation {\n\n    private  long combination(int n, int r) {\n\t\tFactorial fac = new Factorial();\n\t\tlong combin;\n\t\tcombin = fac.factorial(n) / (fac.factorial(r) * fac.factorial(n-r));\n\t\treturn combin;\n\t}\n\n\tprivate  long permutation(int n, int r) {\n\t\tFactorial fac = new Factorial();\n\t\tlong permut;\n\t\tpermut = fac.factorial(n) / fac.factorial(n-r);\n\t\treturn permut;\n\t}\n\n\tpublic  long select(int n, int r, boolean flag) {\n\t\treturn flag ? combination(n, r) : permutation(n, r);\n\t}\n}',
    groundTruth:
      'public class CombinationPermutation {\n\t//@ requires 0 <= n && n <= 20 && 0 <= r && r <= n;\n\t//@ old Factorial fac_spec = new Factorial();\n\t//@ ensures \\result == fac_spec.spec_factorial(n)/(fac_spec.spec_factorial(r) * fac_spec.spec_factorial(n-r));\n        private /* pure @*/ long combination(int n, int r) {\n\t\tFactorial fac = new Factorial();\n\t\tlong combin;\n\t\tcombin = fac.factorial(n) / (fac.factorial(r) * fac.factorial(n-r));\n\t\treturn combin;\n\t}\n\n\t//@ requires 0 <= n && n <= 20 && 0 <= r && r <= n;\n\t//@ old Factorial fac_spec = new Factorial();\n\t//@ ensures \\result == fac_spec.spec_factorial(n)/fac_spec.spec_factorial(n-r);\n\tprivate /* pure @*/ long permutation(int n, int r) {\n\t\tFactorial fac = new Factorial();\n\t\tlong permut;\n\t\tpermut = fac.factorial(n) / fac.factorial(n-r);\n\t\treturn permut;\n\t}\n\n\t/*@ old Factorial fac_spec = new Factorial();\n\t  @ requires 0 <= n && n <= 20 && 0 <= r && r <= n; \t\n\t  @ {|\t\t\n\t  @\trequires flag; \t\n\t  @ \tensures \\result == fac_spec.spec_factorial(n)/(fac_spec.spec_factorial(r) * fac_spec.spec_factorial(n-r));\n\t  @ also\n\t  @\trequires !flag;\n\t  @\tensures \\result == fac_spec.spec_factorial(n)/fac_spec.spec_factorial(n-r); |} @*/\n\tpublic /* pure @*/ long select(int n, int r, boolean flag) {\n\t\treturn flag ? combination(n, r) : permutation(n, r);\n\t}\n}',
  },
  {
    className: 'CopyArray',
    testcase:
      'public class CopyArray {\n \n    public static void CopyArray(int[] b, int iBegin, int iEnd, int[] a) {\n        int k = iBegin;\n\n        while (iEnd - k > 0) {\n            a[k] = b[k];\n            k = k + 1 ;\n        }\n    }\n}',
    groundTruth:
      'public class CopyArray {\n    //@ requires 0 < a.length && 0 < b.length;\n    //@ requires 0 <= iBegin && 0 <= iEnd && iBegin <= iEnd;\n    //@ requires iBegin < a.length && iBegin < b.length && iEnd < a.length && iEnd < b.length;\n    //@ ensures (\\forall int i; iBegin <= i && i < iEnd; a[i] == b[i]);\n    public static void CopyArray(int[] b, int iBegin, int iEnd, int[] a) {\n        int k = iBegin;\n        //@ maintaining iBegin <= k && k <= iEnd;\n        //@ maintaining (\\forall int i; iBegin <= i && i < k; a[i] == b[i]);\n        //@ decreases iEnd  - k;\n        while (iEnd - k > 0) {\n            a[k] = b[k];\n            k = k + 1 ;\n        }\n    }\n}',
  },
  {
    className: 'FIND_FIRST_IN_SORTED',
    testcase:
      'public class FIND_FIRST_IN_SORTED {\n\n    public static int find_first_in_sorted(int[] arr, int x) {\n        int lo = 0;\n        int hi = arr.length;\n\n        while (lo < hi) {\n            int mid = (lo + hi) / 2; \n            if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                return mid;\n            } else if (x <= arr[mid]) {\n                hi = mid;\n            } else { \n                lo = mid + 1;\n            }\n        }\n\t\n        return -1;\n    }\n}',
    groundTruth:
      '//arr.length should be less than half of Integer.MAX_VALUE. Array size greater than ((Integer.MAX_VALUE/2)+1) can lead to sum overfllowing  for "int mid = (lo + hi) / 2;". When argument "X" is not in the array and it is value is larger than all numbers in the array. \npublic class FIND_FIRST_IN_SORTED {\n    //@ requires 0 <= arr.length && arr.length <= (Integer.MAX_VALUE/2)+1; \n    /*@ requires (\\forall int j; 0 <= j && j < arr.length;\n      @             (\\forall int i; 0 <= i && i < j ; arr[i] <= arr[j])); @*/\n    //@ ensures \\result < arr.length;\n    //@ ensures 0 <= \\result && \\result < arr.length ==> arr[\\result] == x && (\\forall int i; 0 <= i && i < \\result; arr[i] != x);\n    //@ ensures \\result == -1 ==> (\\forall int i; 0 <= i && i < arr.length; arr[i] != x);\n    public static int find_first_in_sorted(int[] arr, int x) {\n        int lo = 0;\n        int hi = arr.length;\n\n\t//@ maintaining 0 <= lo && lo <= arr.length; \n        //@ maintaining 0 <= hi && hi <= arr.length;\n\t//@ maintaining lo <= hi;\n        //@ maintaining (\\forall int i; 0 <= i && i < lo; arr[i] < x);\n        //@ maintaining (\\forall int i; hi < i && i < arr.length; x <= arr[i]);\n        while (lo < hi) {\n            int mid = (lo + hi) / 2; // check if this is floor division\n            if (x == arr[mid] && (mid == 0 || x != arr[mid-1])) {\n                return mid;\n            } else if (x <= arr[mid]) {\n                hi = mid;\n            } else { \n                lo = mid + 1;\n            }\n        }\n\t//@ assume (\\forall int i; 0 <= i && i < arr.length; arr[i] != x);\n        return -1;\n    }\n}',
  },
  {
    className: 'FIND_IN_SORTED',
    testcase:
      'public class FIND_IN_SORTED {\n    \n    public static int binsearch(int[] arr, int x, int start, int end) {\n        if (start == end) {\n            return -1;\n        }\n        int mid = start + (end - start) / 2; \n        if (x < arr[mid]) {\n            return binsearch(arr, x, start, mid);\n        } else if (x > arr[mid]) {\n            return binsearch(arr, x, mid+1, end);\n        } else {\n            return mid;\n        }\n    }\n\n    public static int find_in_sorted(int[] arr, int x) {\n        return binsearch(arr, x, 0, arr.length);\n    }\n}',
    groundTruth:
      'public class FIND_IN_SORTED {\n    /*@ requires  0 <= start && 0 <= end && start <= end && end <= arr.length; \n      @ requires (\\forall int j; 0 <= j && j < arr.length; \n      @                        (\\forall int i; 0 <= i && i < j; arr[i] <= arr[j]));\n      @ ensures (0 <= \\result && \\result < arr.length) ==> arr[\\result] == x;\n      @ ensures (start < end && 0 <= \\result && \\result < end) \n      @     ==> (arr[start] <= arr[\\result] && arr[\\result] <= arr[end-1]);\n      @ ensures \\result < end;\n      @ ensures (start == end) ==> \\result == -1;\n      @ ensures \\result == -1 ==> (\\forall int i; start <= i && i < end; arr[i] != x); @*/\n    public static /*@ pure @*/\n    int binsearch(int[] arr, int x, int start, int end) {\n        if (start == end) {\n            return -1;\n        }\n        int mid = start + (end - start) / 2; // check this is floor division\n        if (x < arr[mid]) {\n            return binsearch(arr, x, start, mid);\n        } else if (x > arr[mid]) {\n            return binsearch(arr, x, mid+1, end);\n        } else {\n            return mid;\n        }\n    }\n\n    //@ requires \\forall int j; 0 <= j && j < arr.length; \\forall int i; 0 <= i && i < j ;arr[i] <= arr[j];\n    //@ ensures 0 <= \\result && \\result < arr.length ==> arr[\\result] == x;\n    //@ ensures \\result == -1 ==> (\\forall int i; 0 <= i && i < arr.length; arr[i] != x);\n    public static int find_in_sorted(int[] arr, int x) {\n        return binsearch(arr, x, 0, arr.length);\n    }\n}',
  },
  {
    className: 'Factorial',
    testcase:
      'public class Factorial\n{\n   public  long factorial(int n)\n   {\n      int c;\n      long fact = 1;\n\n   \n      if (n == 0) {         \n            return fact;\n      }\n\n      for (c = 1; c <= n; c++) { \n            fact = fact*c;\n      }\t \n\n      return fact;\n   }\n\n}',
    groundTruth:
      'public class Factorial\n    {\n       //@ requires 0 <= n && n <= 20;\n       //@ ensures \\result >= 1 && \\result <= Long.MAX_VALUE;\n       //@ ensures \\result == spec_factorial(n);\n       public /* pure @*/ long factorial(int n)\n       {\n          int c;\n          long fact = 1;\n\n\t  //@ assert spec_factorial(0) == 1;\n\t   if (n == 0) {         \n              return fact;\n\t   }\n\n          //@ maintaining c >= 1 && c <= n+1;\n\t  //@ maintaining fact > 0;\n\t  //@ maintaining fact <= Long.MAX_VALUE; \n\t  //@ maintaining spec_factorial(c - 1) == fact;\n\t  //@ decreases n - c;\n          for (c = 1; c <= n; c++) { \n                fact = fact*c;\n             }\t \n\n          return fact;\n      }\n\n\t/*@ \trequires n > 0 && n <= 20;\n            \tensures 0 <= \\result && \\result <= Long.MAX_VALUE;\n            \tensures n > 0 ==> \\result == n * spec_factorial(n-1);\n            also\n            \trequires n == 0;\n            \tensures \\result == 1;\n        public model function static pure long spec_factorial(int n) { \n\t    if (n == 0) {\n\t\t return 1; \n\t    }\n\t    else {\n\t        assert n * spec_factorial(n-1) <= Long.MAX_VALUE;\n\t\treturn n * spec_factorial(n-1);\n\t    }\n        }@*/\n     }',
  },
  {
    className: 'Fibonacci',
    testcase:
      'public class Fibonacci {\n   \tprivate  long fib[];\n\n\tFibonacci() {\n\t\tfib = new long[2];\n\t\tfib[0] = 0;\n\t\tfib[1] = 1;\n\t}\n\t \t\n\t Fibonacci(int size) {\n\t\tif (2 <= size && size <= 93) {\n\t\t\tfib = new long[size];\t\n\t\t\tfib[0] = 0;\n\t\t\tfib[1] = 1;\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\tpublic  long getFib(int index) {\n\t\treturn fib[index];\n\t}\n\n\tpublic void fibCompute() {\n\t\tint index = 2;\n      \n\t\twhile (index < fib.length) {\n\t\n\t\t\tfib[index] = fib[index - 2] + fib[index - 1];\n\t\t\tindex++;\n                        \n\t\t}\n\t}\n}',
    groundTruth:
      'public class Fibonacci {\n   \tprivate /*@ spec_public @*/ long fib[];\n\t//@ public invariant 2 <= fib.length && fib.length <= 93; // 93 < size ==> Long Overflow \n\n\t//@ ensures fib[0] == 0 && fib[1] == 1;\n\tFibonacci() {\n\t\tfib = new long[2];\n\t\tfib[0] = 0;\n\t\tfib[1] = 1;\n\t}\n\t/*@ \tpublic normal_behavior\n\t  @ \t\trequires 2 <= size && size <= 93;\n\t  @ \t\tensures fib[0] == 0 && fib[1] == 1;\n\t  @ \t\tensures (\\forall int i; 2 <= i && i < fib.length; fib[i] == 0);\n\t  @ also\n\t  @ \tpublic exceptional_behavior\n   \t  @ \t\trequires size < 2 || 93 < size;\n\t  @\t\tassignable \\nothing;\n\t  @ \t\tsignals_only IllegalArgumentException; @*/ \t\n\t/*@ spec_public @*/ Fibonacci(int size) {\n\t\tif (2 <= size && size <= 93) {\n\t\t\tfib = new long[size];\t\n\t\t\tfib[0] = 0;\n\t\t\tfib[1] = 1;\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\t}\n\n\t//@ requires 0 <= index && index < fib.length;\n\t//@ ensures \\result == fib[index];\n\tpublic /*@ pure @*/ long getFib(int index) {\n\t\treturn fib[index];\n\t}\n\t\n\t//@ requires fib[0] == 0 && fib[1] == 1;\n\t//@ assignable fib[2 .. fib.length-1]; \n\t//@ ensures (\\forall int i; 2 <= i && i < fib.length; fib[i] == fib[i-1] + fib[i-2]); \n\t//@ ensures (\\forall int i; 2 <= i && i < fib.length; (\\forall int j; 2 <= j && j < i; fib[j] < fib[i]));\n\tpublic void fibCompute() {\n\t\tint index = 2;\n\t\t//@ maintaining 2 <= index && index <= fib.length;\n                //@ maintaining (\\forall int i; 2 <= i && i < index; fib[i] == fib[i-1] + fib[i-2]);\n                //@ maintaining (\\forall int i; 2 <= i && i < index; (\\forall int j; 2 <= j && j < i; fib[j] < fib[i]));\n\t\twhile (index < fib.length) {\n\t\t\t//@ assume fib[index - 2] + fib[index - 1] <= Long.MAX_VALUE;\n\t\t\t//@ assume 0 < fib[index - 2] + fib[index - 1];\n\t\t\tfib[index] = fib[index - 2] + fib[index - 1];\n\t\t\tindex++;\n                        //@ assume fib[index-2] <  fib[index-1];\n\t\t}\n\t}\n}',
  },
  {
    className: 'FindFirstZero',
    testcase:
      'public class FindFirstZero {\n\n    \t public static int FindFirstZero(int[] x) {\n         \tassert x.length >= 0;\n         \tif (x.length == 0) {\n            \t\treturn -1;\n        \t} else {\n            \t\tint index = 0;\n\n            \t\twhile (x.length - index > 0 && x[index] != 0) {\n                \t\tindex = index + 1;\n            \t\t}\n            \t\tif (x.length - index == 0) {\n               \t\t\tindex = -1;\n            \t\t}\n            \treturn index;\n        \t}\n    \t}\n}',
    groundTruth:
      'public class FindFirstZero {\n\t //@ ensures x.length == 0 ==> \\result == -1;\n   \t //@ ensures 0 <= \\result && \\result < x.length ==> x[\\result] == 0 && (\\forall int i; 0 <= i && i < \\result; x[i] != 0);\n\t //@ ensures \\result == -1 ==> (\\forall int i; 0 <= i && i < x.length; x[i] != 0);\n    \t public static int FindFirstZero(int[] x) {\n         \tassert x.length >= 0;\n         \tif (x.length == 0) {\n            \t\treturn -1;\n        \t} else {\n            \t\tint index = 0;\n            \t\t//@ maintaining (\\forall int i; 0 <= i && i < index; x[i] != 0);\n            \t\t//@ maintaining (0 <= index && index <= x.length);\n            \t\t//@ decreases x.length - index;\n            \t\twhile (x.length - index > 0 && x[index] != 0) {\n                \t\tindex = index + 1;\n            \t\t}\n            \t\tif (x.length - index == 0) {\n               \t\t\tindex = -1;\n            \t\t}\n            \treturn index;\n        \t}\n    \t}\n}',
  },
  {
    className: 'FindInArray',
    testcase:
      'class FindInArray {\n    private  int key;\n    private  int arr[];\n\n    FindInArray(int inputArr[])\n    {\n\tint size = inputArr.length;\n\tarr = new int[size];\n\tarr = inputArr.clone();\n    } \n \n    FindInArray(int inputArr[], int key)\n    {\n\tint size = inputArr.length;\n\tarr = new int[size];\n\tarr = inputArr.clone();\n        setKey(key);\n    } \n\n    void setKey(int key) \n    {\n\tthis.key = key;\n    }\n\n     int getKey() \n    {\n\treturn this.key;\n    }\n\n     int getArr(int i) \n    {\n\treturn this.arr[i];\n    }\n\n     int size() \n    {\n   \treturn arr.length;\n    }\n\n    \n     int findLast() {\n\tint index = size() - 1;\n\t\n\t\n\twhile (0 <= index) {\n\t\tif (getArr(index) == getKey())\n\t\t\treturn index;\n\t\tindex--;\n\t}\n\treturn -1;\n    }\n\n    \n     int findFirst() {\t\n\t\n\t\n\tfor (int index = 0; index < size(); index++) {\n\t\tif (getArr(index) == getKey())\n\t\t\treturn index;\n\t}\n\treturn -1;\n    }\n    \n    \n     boolean isMoreThanOneKey() {\n\tint first = findFirst();\n\tint last = findLast();\n\treturn (first != last);\n    }\n}',
    groundTruth:
      'class FindInArray {\n    private /*@ spec_public @*/ int key;\n    private /*@ spec_public @*/ int arr[];\n\n    //@ ensures (\\forall int i; 0 <= i && i < inputArr.length; inputArr[i] == arr[i]);\n    //@ ensures key == 0;\n    FindInArray(int inputArr[])\n    {\n\tint size = inputArr.length;\n\tarr = new int[size];\n\tarr = inputArr.clone();\n    } \n\n    //@ ensures this.key == key;\n    //@ ensures (\\forall int i; 0 <= i && i < inputArr.length; inputArr[i] == arr[i]);\n    FindInArray(int inputArr[], int key)\n    {\n\tint size = inputArr.length;\n\tarr = new int[size];\n\tarr = inputArr.clone();\n        setKey(key);\n    } \n\n    //@ assignable this.key;\n    //@ ensures this.key == key;\n    void setKey(int key) \n    {\n\tthis.key = key;\n    }\n\n    //@ ensures \\result == this.key;\n    /*@ pure @*/ int getKey() \n    {\n\treturn this.key;\n    }\n    //@ requires 0 <= i && i < arr.length;\n    //@ ensures \\result == this.arr[i];\t\n    /*@ pure @*/ int getArr(int i) \n    {\n\treturn this.arr[i];\n    }\n\n    //@ ensures \\result == arr.length;\t\n    /*@ pure @*/ int size() \n    {\n   \treturn arr.length;\n    }\n\n    /*@ ensures 0 <= \\result && \\result < arr.length ==> (arr[\\result] == key && \n      @\t\t\t(\\forall int i; \\result < i && i < arr.length; arr[i] != key)); \n      @ ensures \\result == -1 ==> (\\forall int i; 0 <= i && i < arr.length; arr[i] != key); @*/\n    /*@ pure @*/ int findLast() {\n\tint index = size() - 1;\n\t//@ maintaining -1 <= index && index < arr.length; \n\t//@ maintaining (\\forall int i; index < i && i < arr.length; arr[i] != key);\n\twhile (0 <= index) {\n\t\tif (getArr(index) == getKey())\n\t\t\treturn index;\n\t\tindex--;\n\t}\n\treturn -1;\n    }\n\n    /*@ ensures 0 <= \\result && \\result < arr.length ==> (arr[\\result] == key && \n      @\t\t\t(\\forall int i; 0 <= i && i < \\result; arr[i] != key)); \n      @ ensures \\result == -1 ==> (\\forall int i; 0 <= i && i < arr.length; arr[i] != key); @*/\n    /*@ pure @*/ int findFirst() {\t\n\t//@ maintaining 0 <= index && index <= arr.length;\n\t//@ maintaining (\\forall int i; 0 <= i && i < index; arr[i] != key);\n\tfor (int index = 0; index < size(); index++) {\n\t\tif (getArr(index) == getKey())\n\t\t\treturn index;\n\t}\n\treturn -1;\n    }\n    \n    //@ ensures \\result <==> findLast() != findFirst();\n    /*@ pure @*/ boolean isMoreThanOneKey() {\n\tint first = findFirst();\n\tint last = findLast();\n\treturn (first != last);\n    }\n}',
  },
  {
    className: 'GCD',
    testcase:
      'public class GCD {\n\t\n        public static int div(int n, int d) { \n\t\treturn n%d; \n\t}\n\n\tpublic  int absolute(int num) {\n\t\treturn (0 <= num) ? num : -num;\n\t}\n    \n\tpublic  int gcd(int num1, int num2) throws IllegalArgumentException {\n\t\tint result = 1; \n\t \tnum1 = absolute(num1);\n\t\tnum2 = absolute(num2);\n\n\t\tif (num1 == 0 && num2 == 0) {\n\t\t\treturn -1;\t\n\t\t}\n\n\t\tif (num1 == 0 || num2 == 0) { \n\t\t\treturn (num1 > num2) ? num1 : num2;\n\t\t}\n\n\t\tfor (int i = 1; i <= num1 && i <= num2; i++) {\n            \t\tif (div(num1,i) == 0 && div(num2,i) == 0) {\n               \t\t\tresult = i;\n\t\t\t}\n        }\n\t\treturn result;\n\t} \n}',
    groundTruth:
      'public class GCD {\n\t/*@ public normal_behavior     \n          @    requires d != 0;\n\t  @    ensures \\result == n%d;\n          @    pure function @*/\n        public static int div(int n, int d) { \n\t\treturn n%d; \n\t}\n\n\t/*@    requires 0 <= num && num <= Integer.MAX_VALUE;\n\t  @    ensures \\result == num;\n\t  @ also\n\t  @    requires Integer.MIN_VALUE < num && num < 0;\n\t  @    ensures \\result == -num; @*/\n\tpublic /*@ pure @*/ int absolute(int num) {\n\t\treturn (0 <= num) ? num : -num;\n\t}\n\n        /*@ requires num1 != Integer.MAX_VALUE && num2 != Integer.MAX_VALUE && Integer.MIN_VALUE + 1 < num1 && Integer.MIN_VALUE + 1 < num2;\n          @ {|  \n\t  @    requires num1 != 0 && num2 != 0;\n\t  @    old int tnum1 = absolute(num1);\n\t  @    old int tnum2 = absolute(num2);\n\t  @    old int greater = (tnum2 < tnum1) ? tnum1 : tnum2;\n\t  @    old int smaller = (tnum2 < tnum1) ? tnum2 : tnum1;\n\t  @    ensures \\result > 0;\n\t  @    ensures div(tnum1,\\result) == 0;\n\t  @    ensures div(tnum2,\\result) == 0;\n\t  @    ensures (\\forall int i; \\result < i && i <= smaller; div(smaller,i) == 0 ==> div(greater,i) != 0);\n\t  @ also\n\t  @    requires num1 == 0 && num2 != 0;\n\t  @    requires num2 != Integer.MIN_VALUE;\n\t  @    old int tnum2 = absolute(num2);\n\t  @    ensures \\result == tnum2;\n\t  @ also\n\t  @    requires num1 != 0 && num2 == 0;\n\t  @    requires num1 != Integer.MIN_VALUE;\n\t  @    old int tnum1 = absolute(num1);\n\t  @    ensures \\result == tnum1;\n\t  @ also\n\t  @    requires num1 == 0 && num2 == 0;\n\t  @    ensures \\result == -1;\n          @ |} @*/\n\tpublic /*@ pure @*/ int gcd(int num1, int num2) throws IllegalArgumentException {\n\t\tint result = 1; \n\t \tnum1 = absolute(num1);\n\t\tnum2 = absolute(num2);\n\t\n\t\t//@ assume div(num1, result) == 0 && div(num2, result) == 0;\n\n\t\tif (num1 == 0 && num2 == 0) {\n\t\t\treturn -1;\t\n\t\t}\n\n\t\tif (num1 == 0 || num2 == 0) { \n\t\t\treturn (num1 > num2) ? num1 : num2;\n\t\t}\n\n\t\t//@ maintaining result <= num1 && result <= num2;\n\t\t//@ maintaining 0 < i && i <= num1 + 1 && i<= num2 + 1; \n\t\t//@ maintaining 0 < result && result <= i;\n\t\t//@ maintaining div(num1, result) == 0 && div(num2, result) == 0;\n\t\t//@ maintaining (\\forall int j; 0 < j &&  j < i; div(num1, j) == 0 && div(num2, j) == 0 ==> j <= result);\n\t\t//@ decreases num1 - i; \n\t\tfor (int i = 1; i <= num1 && i <= num2; i++) {\n            \t\tif (div(num1,i) == 0 && div(num2,i) == 0) {\n               \t\t\tresult = i;\n\t\t\t}\n        \t}\n\t\treturn result;\n\t} \n}',
  },
  {
    className: 'Inverse',
    testcase:
      'public class Inverse {\n\n    public static boolean Inverse(int[] x, int[] y) {\n        if (x.length != y.length) return false;\n        int index = 0;\n\n        while (index < x.length) {\n            if (x[index] != y[x.length - 1 - index]) {\n                return false;\n            } else {\n                index = index + 1;\n            }\n        }\n        return true;\n    }\n}',
    groundTruth:
      'public class Inverse {\n    //@ ensures !\\result ==> ((x.length != y.length) || (\\exists int i; 0 <= i && i < x.length; x[i] != y[x.length - 1 -i]));\n    //@ ensures \\result ==> x.length == y.length && (\\forall int i; 0 <= i && i < x.length; x[i] == y[x.length - 1 - i]);\n    public static boolean Inverse(int[] x, int[] y) {\n        if (x.length != y.length) return false;\n        int index = 0;\n        //@ maintaining 0 <= index && index <= x.length && x.length == y.length;\n        //@ maintaining (\\forall int i; 0 <= i && i < index; x[i] == y[x.length -1 - i]);\n        //@ decreases x.length - index;\n        while (index < x.length) {\n            if (x[index] != y[x.length - 1 - index]) {\n                return false;\n            } else {\n                index = index + 1;\n            }\n        }\n        return true;\n    }\n}',
  },
  {
    className: 'LCM',
    testcase:
      'public class LCM {\n    \n    public static int div(int n, int d) { return n%d; }\n\n    public  int lcm(int num1, int num2) \n    {\n\tif (num1 == 0 || num2 == 0) {\n\t\treturn -1;\n\t}\t\n\tif (num1 < 0)\n\t\tnum1 = -num1;\n\tif (num2 < 0)\n\t\tnum2 = -num2;\n\n        int result = (num1 > num2) ? num1 : num2;\n\n        while (result < Integer.MAX_VALUE)\n        {\n            if (div(result, num1) == 0 && div(result, num2) == 0)\n            {\n                break;\n            }\n            result++;\n        }\n\n\tif (div(result, num1) == 0 && div(result, num2) == 0) {\n\t\treturn result;\n\t}\n\treturn -1;\n    }\n}',
    groundTruth:
      'public class LCM {\n    /*@ public normal_behavior     \n      @    requires d != 0;\n      @    ensures \\result == n%d;\n      @    pure function @*/\n    public static int div(int n, int d) { return n%d; }\n\n    /*@ requires num1 != Integer.MIN_VALUE;\n      @ requires num2 != Integer.MIN_VALUE;\n      @ {|\n      @    requires num1 != 0 && num2 != 0;\n      @    old int pNum1 = (num1 > 0) ? num1 : -num1;\n      @    old int pNum2 = (num2 > 0) ? num2 : -num2;\n      @    old int max = (pNum1 > pNum2) ? pNum1 : pNum2;\n      @    ensures \\result == -1 || 0 < \\result; \n      @    ensures 0 < \\result ==> (div(\\result, pNum2) == 0 && div(\\result, pNum2) == 0);\n      @    ensures 0 < \\result ==> (\\forall int i; max <= i && i < \\result; div(i, pNum1) == 0 ==> div(i, pNum2) != 0);\n      @    ensures \\result == -1 ==> (\\forall int k; max <= k && k <= Integer.MAX_VALUE; div(k, pNum1) == 0 ==> div(k, pNum2) != 0); \n      @ also\n      @    requires num1 == 0 || num2 == 0;\n      @    ensures \\result == -1;\n      @ |} @*/\n    public /*@ pure @*/ int lcm(int num1, int num2) \n    {\n\tif (num1 == 0 || num2 == 0) {\n\t\treturn -1;\n\t}\t\n\tif (num1 < 0)\n\t\tnum1 = -num1;\n\tif (num2 < 0)\n\t\tnum2 = -num2;\n\n        int result = (num1 > num2) ? num1 : num2;\n\t\n\t//@ ghost int check = result; \n\t//@ maintaining num1 <= result && num2 <= result && result <= Integer.MAX_VALUE;\n\t//@ maintaining (\\forall int k; check <= k && k < result; div(k, num1) == 0 ==> div(k, num2) != 0);\n\t//@ decreases Integer.MAX_VALUE - result;\n        while (result < Integer.MAX_VALUE)\n        {\n            if (div(result, num1) == 0 && div(result, num2) == 0)\n            {\n                break;\n            }\n            result++;\n        }\n\n\tif (div(result, num1) == 0 && div(result, num2) == 0) {\n\t\treturn result;\n\t}\n\treturn -1;\n    }\n}',
  },
  {
    className: 'LeapYear',
    testcase:
      'public class LeapYear {\n    \n    public  boolean isLeapYear(int year) {\n        boolean leap = false;\n         \n        if (year % 4 == 0)\n        {\n            if ( year % 100 == 0)\n            {\n                if ( year % 400 == 0)\n                    leap = true;\n                else\n                    leap = false;\n            }\n            else\n                leap = true;\n        }\n        else\n            leap = false;\n\t\n\treturn leap;\n   }\n}',
    groundTruth:
      'public class LeapYear {\n    /*@ requires 0 < year;\n    {|\n       @    requires year % 4 != 0;\n       @    ensures \\result == false;\n       @ also\n       @     requires year % 4 == 0 && year % 100 != 0;\n       @     ensures \\result == true;\n       @ also\n       @     requires year % 4 == 0 && year % 100 == 0 && year % 400 != 0;\n       @     ensures \\result == false;\n       @ also\n       @     requires year % 4 == 0 && year % 100 == 0 && year % 400 == 0;\n       @     ensures \\result == true;\n    |} @*/\n    public /*@ pure @*/ boolean isLeapYear(int year) {\n        boolean leap = false;\n\n        if (year % 4 == 0)\n        {\n            if ( year % 100 == 0)\n            {\n                if ( year % 400 == 0)\n                    leap = true;\n                else\n                    leap = false;\n            }\n            else\n                leap = true;\n        }\n        else\n            leap = false;\n\n\treturn leap;\n   }\n}',
  },
  {
    className: 'LinearSearch',
    testcase:
      'public class LinearSearch {\n     private static  int location;\n\n      public static int linearSearch(int search, int array[]) {\n\t      int c;\n\n        for (c = 0; c < array.length; c++) {  \n          if (array[c] == search) {\n\t      location = c;\n              break;\n          }\n        }\n       if (c == array.length) {\n            location = -1;\n       }\n     return location;\n     }\n  }',
    groundTruth:
      'public class LinearSearch {\n     private static /*@ spec_public*/ int location;\n\n      //@ assignable location;\n      //@ ensures \\result == -1 <==>  (\\forall int i; 0 <= i && i < array.length; array[i] != search);\n      //@ ensures 0 <= \\result && \\result < array.length ==>  array[\\result] == search;\n      public static int linearSearch(int search, int array[]) {\n\tint c;\n\t//@ maintaining 0 <= c && c <= array.length;\n\t//@ maintaining (\\forall int i; 0 <= i && i < c; array[i] != search);\n\t//@ decreases array.length - c;\n        for (c = 0; c < array.length; c++) {  \n          if (array[c] == search) {\n\t      location = c;\n              break;\n          }\n       }\n       if (c == array.length) {\n            location = -1;\n       }\n     return location;\n     }\n  }',
  },
  {
    className: 'Neg',
    testcase:
      'public class Neg {\n\tpublic int Negation(int num) {\n\t\treturn -num;\n\t}\n}',
    groundTruth:
      'public class Neg {\n\t//@ ensures \\result == -num;\n\tpublic int Negation(int num) {\n\t\t//@ assume num > Integer.MIN_VALUE;\n\t\treturn -num;\n\t}\n}',
  },
  {
    className: 'OddEven',
    testcase:
      'public class OddEven {\t\n \n\t public  boolean isEven(int x) { \n         \treturn x%2 == 0;\n       \t } \n\n\t public  boolean isOdd(int x) { \n         \treturn x%2 != 0;\n       \t } \n}',
    groundTruth:
      'public class OddEven {\t\n    \t //@ ensures \\result <==>  x%2 == 0;\n    \t //@ ensures !\\result <==> x%2 != 0;\n\t public /*@ pure @*/ boolean isEven(int x) { \n         \treturn x%2 == 0;\n       \t } \n\n    \t //@ ensures !\\result <==> x%2 == 0;\n    \t //@ ensures \\result <==>  x%2 != 0;\n\t public /*@ pure @*/ boolean isOdd(int x) { \n         \treturn x%2 != 0;\n       \t } \n}',
  },
  {
    className: 'Perimeter',
    testcase:
      'public class Perimeter\n{   \n\n     long Perimeter(short x)\n    {\n\tlong squarePerimeter = 4 * (long)x;\n\treturn squarePerimeter;\n    }\n\n     long Perimeter(int x)\n    {\n\tlong pentagonPerimeter = 5 * (long)x;\n\treturn pentagonPerimeter;\n    }\n\n     long Perimeter(long x)\n    {\n\tlong hexagonalPerimeter = 6 * x;\n\treturn hexagonalPerimeter;\n    }\n\n     long Perimeter(int x, int y)\n    {\n\tlong perimeterRectangle = 2*((long)x + (long)y);\n\treturn perimeterRectangle;\n    }\n\n     long Perimeter(int x, int y, int z)\n    {\n\tlong trianglePerimeter = (long)x + (long)y + (long)z;\n\treturn trianglePerimeter;\n    }\n\n     long Perimeter(int w, int x, int y, int z)\n    {\n\tlong trapeziumPerimeter = (long)w + (long)x + (long)y + (long)z;\n\treturn trapeziumPerimeter;\n    }\n}',
    groundTruth:
      'public class Perimeter\n{   \n    //@ requires 0 < x && x <= Short.MAX_VALUE;\n    //@ ensures \\result == 4*x;\n    /*@ pure @*/ long Perimeter(short x)\n    {\n\tlong squarePerimeter = 4 * (long)x;\n\treturn squarePerimeter;\n    }\n\n    //@ requires 0 < x && x <= Integer.MAX_VALUE;\n    //@ ensures \\result == 5*x;\n    /*@ pure @*/ long Perimeter(int x)\n    {\n\tlong pentagonPerimeter = 5 * (long)x;\n\treturn pentagonPerimeter;\n    }\n\n    //@ requires 0 < x && 6*x <= Long.MAX_VALUE;\n    //@ ensures \\result == 6*x;\n    /*@ pure @*/ long Perimeter(long x)\n    {\n\tlong hexagonalPerimeter = 6 * x;\n\treturn hexagonalPerimeter;\n    }\n\n    //@ requires 0 < x && 0 < y && 2*x + 2*y <= Integer.MAX_VALUE;\n    //@ ensures \\result == 2*x + 2*y;\n    /*@ pure @*/ long Perimeter(int x, int y)\n    {\n\tlong perimeterRectangle = 2*((long)x + (long)y);\n\treturn perimeterRectangle;\n    }\n\n    //@ requires 0 < x && 0 < y && 0 < z && x + y + z <= Integer.MAX_VALUE;\n    //@ ensures \\result == x + y + z;\n    /*@ pure @*/ long Perimeter(int x, int y, int z)\n    {\n\tlong trianglePerimeter = (long)x + (long)y + (long)z;\n\treturn trianglePerimeter;\n    }\n  \n    //@ requires 0 < w && 0 < x && 0 < y && 0 < z && w + x + y + z <= Integer.MAX_VALUE;\n    //@ ensures \\result == w + x + y + z;\n    /*@ pure @*/ long Perimeter(int w, int x, int y, int z)\n    {\n\tlong trapeziumPerimeter = (long)w + (long)x + (long)y + (long)z;\n\treturn trapeziumPerimeter;\n    }\n}',
  },
  {
    className: 'PerimeterDriver',
    testcase:
      'public class PerimeterDriver {\n\t\n\t public  long driver(int select, int w, int x, int y, int z, short shortNum, long longNum) {\n\n\t\tPerimeter p = new Perimeter();\n\t\tlong result = 0;\n\n\t\tswitch (select) {\n\t\tcase 0:\n\t\t\tresult = p.Perimeter(shortNum);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tresult = p.Perimeter(w);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tresult = p.Perimeter(longNum);\n\t\t\tbreak;\n\t\tcase 3:\t\n\t\t\tresult = p.Perimeter(w, x);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tresult = p.Perimeter(w, x, y);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tresult = p.Perimeter(w, x, y, z);\n\t\t\tbreak;\n\t\t}\n\t\treturn result;\n\t}\n}',
    groundTruth:
      'public class PerimeterDriver {\n\t/*@ requires 0 <= select && select < 6;\n\t  @ {|\n\t     @    requires select == 0;\n\t     @    requires 0 < shortNum && shortNum <= Short.MAX_VALUE;\n\t     @    ensures \\result == 4*shortNum;\n\t     @ also \n\t     @    requires select == 1;\n\t     @    requires 0 < w && w <= Integer.MAX_VALUE;\n\t     @    ensures \\result == 5*w;\n\t     @ also \n\t     @    requires select == 2;\n\t     @    requires 0 < longNum && 6*longNum <= Long.MAX_VALUE;\n\t     @    ensures \\result == 6*longNum;\n\t     @ also \n\t     @    requires select == 3;\n\t     @    requires 0 < w && 0 < x && 2*w + 2*x <= Integer.MAX_VALUE;\n             @    ensures \\result == 2*w + 2*x;\n\t     @ also \n\t     @    requires select == 4;\n\t     @    requires 0 < w && 0 < x && 0 < y && w + x + y <= Integer.MAX_VALUE;\n\t     @    ensures \\result == w + x + y;\n\t     @ also \n\t     @    requires select == 5;\n\t     @    requires 0 < w && 0 < x && 0 < y && 0 < z && w + x + y + z <= Integer.MAX_VALUE;\n\t     @    ensures \\result == w + x + y + z;\n\t  @ |} @*/\n\t public /*@ pure @*/ long driver(int select, int w, int x, int y, int z, short shortNum, long longNum) {\n\n\t\tPerimeter p = new Perimeter();\n\t\tlong result = 0;\n\n\t\tswitch (select) {\n\t\tcase 0:\n\t\t\tresult = p.Perimeter(shortNum);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tresult = p.Perimeter(w);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tresult = p.Perimeter(longNum);\n\t\t\tbreak;\n\t\tcase 3:\t\n\t\t\tresult = p.Perimeter(w, x);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tresult = p.Perimeter(w, x, y);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tresult = p.Perimeter(w, x, y, z);\n\t\t\tbreak;\n\t\t}\n\t\treturn result;\n\t}\n}',
  },
  {
    className: 'PrimeCheck',
    testcase:
      'class PrimeCheck {\n   \n   public static int div(int n, int d) { return n%d; }\n\n   public boolean isPrime(int a) {\n\t\n\tint i = 2;\n\tint mid = a/2;\n\n\twhile (i <= mid) {\n\t   if (div(a,i) == 0)\n\t\treturn false;\n\t   i++;\n\t}\n\treturn true;\n   }\n}',
    groundTruth:
      'class PrimeCheck {\n   /*@ public normal_behavior     \n     @    requires d != 0;\n     @    ensures \\result == n%d; @*/\n   public /*@ pure @*/ static int div(int n, int d) { return n%d; }\n\n   //@ requires 1 < a;\n   //@ ensures \\result ==> (\\forall int k; 1 < k && k <= a/2; div(a, k) != 0);\n   //@ ensures !\\result ==> (\\exists int k; 1 < k && k <= a/2; div(a,k) == 0); \n   public boolean isPrime(int a) {\n\t\n\tint i = 2;\n\tint mid = a/2;\n\n\t//@ ghost int maxnumber = Integer.MAX_VALUE;\t\n\t//@ maintaining 1 < i && i <= mid + 1;\n\t//@ maintaining 2 < i ==> \\forall int k; 1 < k && k < i; div(a, k) != 0; \n\t//@ decreases maxnumber - i;\n\twhile (i <= mid) {\n\t   if (div(a,i) == 0)\n\t\treturn false;\n\t   i++;\n\t}\n\treturn true;\n   }\n}',
  },
  {
    className: 'PrimeNumbers',
    testcase:
      'public class PrimeNumbers\n    {\n        \n        private  static boolean div(int n, int d) { return n%d == 0; }\n\n        private  int primeArray[];\n        \n        public int[] primeList(int n)\n        {\n          int status = 1, num = 3, count, j;\n          primeArray = new int[n];\n          primeArray[0] = 2;\n  \n          for (count = 2; count <= n;)\n          { \n\n             for (j = 2; j <= num/2; j++)\n             { \n                if (div(num,j))\n                {\n                   status = 0;\n                   break;\n                }\n             }\n\n             if (status != 0)\n             {  \n                primeArray[count - 1] = num;\n                count++;\n\t\t\n             }\n             status = 1;\n\t     \n             num++;\n          } \n\t      return primeArray; \n       }\n    }',
    groundTruth:
      '//105,102,357 prime numbers exist between 1 to Integer.MAX_VALUE. Also, the Integer.MAX_VALUE is a prime number. \n    public class PrimeNumbers\n    {\n        /*@ private normal_behavior  \n\t  @    requires 2 <= n;\n          @    requires 2 <= d;\n\t  @    ensures \\result ==> n%d == 0; \n          @    pure function @*/\n        private /*@ spec_public @*/ static boolean div(int n, int d) { return n%d == 0; }\n\n        private /*@ spec_public nullable @*/ int primeArray[];\n        /*@ requires 0 < n && n <= 105102357;\n          @ assignable primeArray;\n\t  @ ensures \\forall int i; 0 <= i && i < primeArray.length; \\forall int j; 2 <= j && j <= primeArray[i]/2; !div(primeArray[i],j);\n\t  @ ensures (\\forall int i,j; 0 <= i && i < primeArray.length && 0 <= j && j < primeArray.length && i != j; primeArray[i] != primeArray[j]);\n\t  @ ensures \\forall int i; 0 <= i && i < primeArray.length; \\forall int j; 0 <= j && j < primeArray.length && i != j; primeArray[i] != primeArray[j]; \n\t  @ ensures primeArray.length == n; @*/\n        public int[] primeList(int n)\n        {\n          int status = 1, num = 3, count, j;\n          primeArray = new int[n];\n          primeArray[0] = 2;\n\t  //@ assert primeArray.length == n;\n\n          /*@ ghost int maxnumber = Integer.MAX_VALUE;\n\t    @ ghost int count_counter = 2;\n\t    @ maintaining (\\forall int i; 0 <= i && i < count-1; (\\forall int k;  2 <= k && k <= primeArray[i]/2; !div(primeArray[i],k)));\n\t    @ maintaining (\\forall int i; 0 <= i && i < count-1; \\forall int k; 0 <= k && k < count-1 && i != k;  primeArray[i] != primeArray[k]);\n\t    @ maintaining (\\forall int i; 0 <= i && i < count-1; primeArray[i] < num);\n            @ maintaining 2 <= count && count <= n + 1 && 3 <= num;\n\t    @ maintaining count_counter == count;\n\t    @ loop_invariant status == 1;\n            @ decreases maxnumber - num; @*/\n          for (count = 2; count <= n;)\n          { \n             //@ maintaining j > 1 && j <= num/2 + 1;\n\t     //@ maintaining (\\forall int k; 0 <= k && k < count - 1; num != primeArray[k]);\n\t     //@ maintaining (\\forall int k; 2 <= k && k < j; !div(num,k));\n             //@ decreases num - j;\n             for (j = 2; j <= num/2; j++)\n             { \n                if (div(num,j))\n                {\n                   status = 0;\n                   break;\n                }\n             }\n\n             if (status != 0)\n             {  \n                primeArray[count - 1] = num;\n                count++;\n\t\t//@ set count_counter = count_counter + 1;\n             }\n             status = 1;\n\t     //@ assume num < Integer.MAX_VALUE;\n             num++;\n          } \n\treturn primeArray; \n       }\n    }',
  },
  {
    className: 'SetZero',
    testcase:
      'public class SetZero {\n\n\tpublic static void SetZero(int[] a, int iBegin, int iEnd) {\n\t\tint k = iBegin;\n\n\t\twhile (k < iEnd) {\n            \t\ta[k] = 0;\n            \t\tk = k + 1 ;\n        \t}\n\t}\n}',
    groundTruth:
      'public class SetZero {\n\t//@ requires a != null;\n\t//@ requires 0 <= iBegin && iBegin <= iEnd && iEnd <= a.length;\n\t//@ ensures (\\forall int i; iBegin <= i && i < iEnd; a[i] == 0);\n\tpublic static void SetZero(int[] a, int iBegin, int iEnd) {\n\t\tint k = iBegin;\n        \t//@ maintaining iEnd - k >= 0;\n        \t//@ maintaining iBegin <= k && k <= iEnd;\n        \t//@ maintaining (\\forall int i; iBegin <= i && i < k; a[i] == 0);\n\t\twhile (k < iEnd) {\n            \t\ta[k] = 0;\n            \t\tk = k + 1 ;\n        \t}\n\t}\n}',
  },
  {
    className: 'Smallest',
    testcase:
      'public class Smallest {\n\n    static public int Smallest(int[] a) {\n        if (a.length == 0) return -1;\n\n        int index = 0;\n        int smallest = 0;\n\n        while (a.length - index > 0) {\n            if (a[index] < a[smallest]) {\n                smallest = index;\n            }\n            index = index + 1;\n        }\n        return smallest;\n    }\n}',
    groundTruth:
      'public class Smallest {\n    //@ ensures \\result == -1 <==> a.length == 0;\n    //@ ensures -1 < \\result ==> (\\forall int i; 0 <= i && i < a.length; a[\\result] <= a[i]);\n    static public int Smallest(int[] a) {\n        if (a.length == 0) return -1;\n\n        int index = 0;\n        int smallest = 0;\n        //@ maintaining 0 <= index && index <= a.length;\n        //@ maintaining 0 <= smallest && smallest < a.length;\n        //@ maintaining (\\forall int i; 0 <= i && i < index; a[smallest] <= a[i]);\n        //@ decreases a.length - index;\n        while (a.length - index > 0) {\n            if (a[index] < a[smallest]) {\n                smallest = index;\n            }\n            index = index + 1;\n        }\n        return smallest;\n    }\n}',
  },
  {
    className: 'StackQueue',
    testcase:
      'public class StackQueue {\n\tpublic class Stack { \n\t \tpublic static final int MAX = 100;   \n\t\n\t   \tprivate  int top;\n\n\t    private  int arr[] = new int[MAX];\n\n\t   \tStack() \n\t   \t{ \n\t        top = -1; \n\t    } \n\t\n\t   \tpublic  int getTop() \n\t    {\n\t        return top;\n\t   \t}\n\n\t\tpublic  boolean isEmpty() \n\t\t{ \n\t\t\treturn (getTop() < 0); \n\t\t} \n\t\n\t\tpublic  boolean isFull() \n\t\t{ \n\t\t\treturn (top == MAX - 1); \n\t\t} \n\n\t\tpublic void push(int x) \n\t\t{ \n\t\t\tif (!isFull()) {\n\t\t\t\t\tarr[++top] = x; \n\t\t\t} else {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t} \n\n\t\tpublic int pop() \n\t\t{ \n\t\t\tif (!isEmpty()) {\n\t\t\t\t\treturn arr[top--]; \n\t\t\t\t} else {\n\t\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t\t}\n\t\t}\n\n\t\tpublic  int peek() \n\t\t{ \n\t\t\tif (!isEmpty())\n\t\t\t\t\treturn arr[top]; \n\t\t\telse\n\t\t\t\t\tthrow new IllegalArgumentException();\n   \t   \t} \n\n\t\tpublic  int search(int key) \n\t\t{\n\t\t\tint index = top;\n\t\t\t\n\t\t\t\n\t\t\twhile (0 <= index) {\n\t\t\t\tif (getElem(index) == key) {\n\t\t\t\t\treturn index;\n\t\t\t\t}\n\t\t\t\tindex--;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\t\n\n\t\tpublic  boolean isContain(int key)\n\t\t{\t\n\t\t\tint index = top;\n\t\t\t\n\t\t\t\n\t\t\twhile (0 <= index) {\n\t\t\t\tif (key == getElem(index)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tindex--;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\t\n\n\t\tpublic  int size() \n\t\t{ \n\t\t\treturn getTop() + 1;\n\t\t}\n\n\t\tpublic  int getElem(int i) \n\t\t{ \n\t\t\treturn arr[i]; \n\t\t}\n\t};\n\n\tpublic class Queue { \n\t\tpublic static final int MAX = 100;   \n\t\tprivate int front, rear; \n\t\tprivate final int queue[] = new int[MAX];\n\n\t\tpublic  Queue() \n\t\t{ \n\t\t\tfront = rear = 0;  \n\t\t} \n\n   \t\tpublic void enter(int data) \n\t\t{ \n\t\t\tif (!isFull()) { \n\t\t\t\t\tqueue[rear] = data; \n\t\t\t\t\trear++; \n\t\t\t} else { \n\t\t\t\t\tthrow new IllegalArgumentException(); \n\t\t\t} \n\t\t} \n\n\t\tpublic int delete() \n\t\t{ \n\t\t\tif (!isEmpty()) { \n\t\t\t\t\tint poll = queue[front];\n\t\t\t\t\t\n\t\t\t\t\tint i = 0;\n\t\t\t\t\t\n\t\t\t\t\twhile (i < rear - 1) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tqueue[i] = queue[i + 1];\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\trear--;\n\t\t\t\t\treturn poll; \n\t\t\t} else {\n\t\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t} \n\n\t\tpublic  int peek() \n\t\t{ \n\t\t\tif (!isEmpty()) { \n\t\t\t\t\treturn queue[front]; \n\t\t\t} else {\n\t\t\t\t\tthrow new IllegalArgumentException(); \n\t\t\t}\n\t\t} \n\n\t\tpublic  boolean isContain(int key)\n\t\t{\n\t\t\tint index = 0;\n\t\t\t\n\t\t\t\n\t\t\twhile (index < rear) {\n\t\t\t\tif (key == queue[index]) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tpublic  int search(int key)\n\t\t{\n\t\t\tint index = 0;\n\t\t\t\n\t\t\t\n\t\t\twhile (index < rear) {\n\t\t\t\t\tif (key == queue[index]) {\n\t\t\t\t\t\treturn index;\n\t\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n   \t\tpublic  boolean isEmpty() \n   \t\t{\n   \t\t     \treturn (getRear() == getFront());\n\t\t}\n\n\t\tpublic  boolean isFull() \n\t\t{\n\t\t\t\tif (MAX == getRear()) \n\t\t\t\t\treturn true;\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t}\n\n\t\tpublic  int size()\n\t\t{\n\t\t\t\treturn rear;\n\t\t}\n\n   \t\tpublic  int getFront() \n    \t{\t\n       \t\t\treturn front; \n   \t\t}\n\t\n\t\tpublic  int getRear() \n\t\t{ \n\t\t\treturn rear; \n\t\t}\n\n\t\tpublic  int getElem(int i) \n\t\t{ \n\t\t\treturn queue[i]; \n\t\t}\n\t}; \n\n    \t\n\tpublic int stackPlus(Stack stack) \n\t{\n\tstack.push(stack.pop() + stack.pop());\n\treturn stack.peek();\n\t}\n\n\t\n\tpublic int stackMinus(Stack stack) \n\t{\n\tstack.push(stack.pop() - stack.pop());\n\treturn stack.peek();\n\t}\n\n\t\n\tpublic int stackDivision(Stack stack) \n\t{\n\tstack.push(stack.pop() / stack.pop());\n\treturn stack.peek();\n\t}\n\n\t\n\tpublic int stackModulus(Stack stack) \n\t{\n\tstack.push(stack.pop() % stack.pop());\n\treturn stack.peek();\n\t}\n\n\t\n\tpublic int QPlus(Queue Q) \n\t{\n\tQ.enter(Q.delete() + Q.delete());\n\treturn Q.getElem(Q.getRear() - 1);\n\t}\n\n\t\n\tpublic int QMinus(Queue Q) \n\t{\n\tQ.enter(Q.delete() - Q.delete());\n\treturn Q.getElem(Q.getRear() - 1);\n\t}\n\n\t\n\tpublic int QDivision(Queue Q) \n\t{\n\tQ.enter(Q.delete() / Q.delete());\n\treturn Q.getElem(Q.getRear() - 1);\n\t}\n\n\t\n\tpublic int QModulus(Queue Q) \n\t{\n\tQ.enter(Q.delete() % Q.delete());\n\treturn Q.getElem(Q.getRear() - 1);\n\t}\t\n\n\n\t\n\n\tpublic  int plusQStack(Queue Q, Stack stack) \n\t{\n\treturn Q.peek() + stack.peek();\n\t}\n\n\t\n\tpublic  int minusQStack(Queue Q, Stack stack) \n\t{\n\treturn Q.peek() - stack.peek();\n\t}\n\n\t\n\tpublic  int qDivideStack(Queue Q, Stack stack) \n\t{\n\treturn Q.peek() / stack.peek();\n\t}\n\n\t\n\tpublic  int stackDivideQ(Queue Q, Stack stack) \n\t{\n\treturn  stack.peek()/Q.peek();\n\t}\t\n\n\t\n\tpublic  int qModulusStack(Queue Q, Stack stack) \n\t{\n\treturn Q.peek() % stack.peek();\n\t}\n\n\t\n\tpublic  int stackModulusQ(Queue Q, Stack stack) \n\t{\n\treturn  stack.peek() % Q.peek();\n\t}\n\t\n\t\n    public int driverStack(Stack stack, int op, int input) \n    {\n\t\tint output = 0;\n\t\tswitch (op) {\n          \t\tcase 0:\n            \t\tstack.push(input);\n\t\t\tbreak;\n\n\t\t\tcase 1:\n            \t\toutput = stack.pop();\n\t\t\tbreak;\n\n\t\t\tcase 2:\n            \t\toutput = stack.search(input);\n\t\t\tbreak;\n\n\t\t\tcase 3:\n            \t\toutput = (stack.isContain(input)) ? 1 : 0;\n\t\t\tbreak;\n\n\t\t\tcase 4:\n            \t\toutput = stackPlus(stack);\n\t\t\tbreak;\n\n\t\t\tcase 5:\n            \t\toutput = stackMinus(stack);\n               \t\t break;\n\n\t\t\tcase 6:\n            \t\toutput = stackDivision(stack);\n               \t\tbreak;\n\n\t\t\tcase 7:\n\t\t\toutput = stackModulus(stack);\n\t\t\tbreak;\n\n\t\t\tdefault:\n            \t\toutput = stack.size();\n\t\t\tbreak;\n\t \t}\n\t\treturn output;\n    }\n\n    \t \n   \tpublic int driverQueue(Queue q, int op, int input)\n    {\n\t\tint output = 0;\n\t\tswitch (op) {\n\t\t\tcase 0:\n           \t\tq.enter(input);\n                \tbreak;\n\n\t\t\tcase 1:\n            \t\toutput = q.delete();\n                \tbreak;\n\n\t\t\tcase 2:\n            \t\toutput = q.search(input);\n                \tbreak;\n\n\t\t\tcase 3:\n            \t\toutput = q.isContain(input) ? 1 : 0;\n               \t\tbreak;\n\n\t\t\tcase 4:\n            \t\toutput = QPlus(q);\n                \tbreak;\n\n\t\t\tcase 5:\n            \t\toutput = QMinus(q);\n                \tbreak;\n\n\t\t\tcase 6:\n            \t\toutput = QDivision(q);\n                \tbreak;\n\n\t\t\tcase 7:\n\t\t\toutput = QModulus(q);\n\t\t\tbreak;\n\n\t\t\tdefault:\n            \t\toutput = q.size();\n                \tbreak;\n\t\t}\n\t\treturn output;\n    }\n\n    \t\n    \tpublic int driverQStack(Stack stack, Queue q, int op) \n    \t{\n\t\t\tStackQueue sq = new StackQueue();\n\t\t\tint output = 0;\n\t\t\tswitch (op) {\n\t\t\t\tcase 0:\n\t\t\t\t\toutput = sq.plusQStack(q, stack);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\t\t\t\t\t\toutput = sq.minusQStack(q, stack);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\t\toutput = sq.qDivideStack(q, stack);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tcase 3:\n\t\t\t\toutput = sq.stackDivideQ(q, stack);\n\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\toutput = sq.qModulusStack(q, stack);\n\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\toutput = sq.stackModulusQ(q, stack);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn output;\n    \t}\n}',
    groundTruth:
      'public class StackQueue {\n\tpublic class Stack { \n\t \tpublic static final int MAX = 100;   // Maximum size of Stack \n\t\n\t   \t private /*@ spec_public @*/ int top;\n\t   \t //@ public invariant -1 <= top && top < MAX;\n\n\t    \tprivate /*@ spec_public @*/ int arr[] = new int[MAX];\n\t    \t//@ public invariant arr.length == MAX; \n\t\n\t    \t//@ ensures top == -1;\n\t   \t/*@ pure @*/ Stack() \n\t   \t{ \n\t        \ttop = -1; \n\t    \t} \n\n\t    \t//@ public normal_behavior\n\t    \t//@   ensures top == \\result;\n\t   \tpublic /*@ pure @*/ int getTop() \n\t    \t{\n\t        \treturn top;\n\t   \t}\n\n\t   \t//@ public normal_behavior\n\t    \t//@   ensures \\result <==> top < 0;\n\t    \t//@   ensures_redundantly !\\result ==> 0 <= top;\n\t    \tpublic /*@ pure @*/ boolean isEmpty() \n\t    \t{ \n\t        \treturn (getTop() < 0); \n\t    \t} \n\n\t    \t//@ public normal_behavior\n\t    \t//@ \tensures \\result <==> top == MAX - 1;\n\t    \t//@   \tensures_redundantly !\\result ==> top < MAX - 1;\n\t    \tpublic /*@ pure @*/ boolean isFull() \n\t    \t{ \n\t        \treturn (top == MAX - 1); \n\t    \t} \n\n\t    \t/*@ public normal_behavior\n\t      \t  @ \trequires !isFull();\n\t          @ \tassignable top, arr[*];\n\t          @ \tensures 0 <= top && top < MAX;\n\t          @ \tensures arr[top] == x;\n\t          @ \tensures top == \\old (top + 1);\n\t          @ \tensures \\forall int i; 0 <= i && i <= arr.length && i != top; arr[i] == \\old (arr[i]);\n\t          @ \tensures_redundantly 0 <= top && top < MAX; \n\n\t          @ also\n\t\t\n\t          @ public exceptional_behavior\n\t          @\trequires isFull();\n\t          @ \tassignable \\nothing;\n\t          @     signals_only IllegalArgumentException; \n\t      \t@*/\n\t    \tpublic void push(int x) \n\t    \t{ \n\t       \t \tif (!isFull()) {\n\t           \t\t arr[++top] = x; \n\t       \t\t } else {\n\t            \t\tthrow new IllegalArgumentException();\n\t       \t\t }\n\t    \t} \n\t\n\t   \t /*@ public normal_behavior\n\t     \t   @ \trequires !isEmpty();\n\t     \t   @ \tassignable top;\n\t      \t   @ \tensures top == \\old (top - 1);\n\t      \t   @ \tensures \\result == \\old (arr[top]);\n\t      \t   @ \tensures \\forall int i; 0 <= i && i <= arr.length; arr[i] == \\old (arr[i]);\n\n     \t      \t   @ also\n\n      \t           @ public exceptional_behavior\n     \t      \t   @ \trequires isEmpty();\n      \t      \t   @ \tassignable \\nothing;\n      \t      \t   @    signals_only IllegalArgumentException; \t\n      \t    \t@*/\n   \t    \tpublic int pop() \n    \t    \t{ \n       \t \t\tif (!isEmpty()) {\n            \t\t\treturn arr[top--]; \n        \t\t } else {\n            \t\t\tthrow new IllegalArgumentException();\n       \t\t\t }\n    \t    \t}\n    \n    \t   \t/*@ public normal_behavior\n     \t     \t  @ \trequires !isEmpty();\n      \t     \t  @ \tensures \\result == arr[top];\n\n      \t     \t  @ also\n\n      \t     \t  @ public exceptional_behavior\n      \t     \t  @ \trequires isEmpty();\n      \t     \t  @     signals_only IllegalArgumentException; \t\n      \t  \t@*/\n    \t   \tpublic /*@ pure @*/ int peek() \n    \t   \t{ \n        \t\tif (!isEmpty())\n            \t\t\treturn arr[top]; \n        \t\telse\n            \t\t\tthrow new IllegalArgumentException();\n   \t   \t} \n\n    \t  \t//@ public normal_behavior\n    \t   \t//@ \tensures 0 <= \\result && \\result <= top ==> arr[\\result] == key;\n    \t   \t//@ \tensures \\result == -1 ==> \\forall int i; 0 <= i && i <= top; arr[i] != key; \n    \t   \tpublic /*@ pure @*/ int search(int key) \n    \t   \t{\n        \t\tint index = top;\n        \t\t//@ maintaining -1 <= index && index <= top; \n        \t\t//@ maintaining (\\forall int i; index < i && i <= top; arr[i] != key);\n        \t\twhile (0 <= index) {\n        \t\t    if (getElem(index) == key) {\n        \t\t        return index;\n        \t\t    }\n        \t\t    index--;\n        \t\t}\n        \t\treturn -1;\n    \t   \t}\t\n\n    \t   \t//@ public normal_behavior\n    \t   \t//@ \tensures \\result ==> \\exists int i; 0 <= i && i <= top; arr[i] == key;\n    \t   \t//@ \tensures !\\result ==> \\forall int i; 0 <= i && i <= top; arr[i] != key;\n    \t   \tpublic /*@ pure @*/ boolean isContain(int key)\n    \t   \t{\t\n        \t\tint index = top;\n        \t\t//@ maintaining -1 <= index && index <= top; \n        \t\t//@ maintaining (\\forall int i; index < i && i <= top; arr[i] != key);\n        \t\twhile (0 <= index) {\n        \t\t    if (key == getElem(index)) {\n        \t\t        return true;\n        \t\t    }\n        \t\t    index--;\n        \t\t}\n        \t\treturn false;\n    \t   \t}\t\n\n    \t   \t//@ public normal_behavior\n    \t   \t//@ \tensures \\result == top + 1;\n    \t   \tpublic /*@ pure @*/ int size() \n    \t   \t{ \n        \t\treturn getTop() + 1;\n    \t   \t}\n\n    \t   \t//@ public normal_behavior\n    \t   \t//@ \trequires 0 <= i && i <= top;\n    \t   \t//@ \tensures \\result == arr[i];\n    \t   \tpublic /*@ pure @*/ int getElem(int i) \n    \t   \t{ \n        \t\treturn arr[i]; \n    \t   \t}\n\t};\n\n\tpublic class Queue { \n    \t\tpublic static final int MAX = 100;   // Maximum size of Queue \n    \t\t/*@ spec_public @*/ private int front, rear; \n    \t\t/*@ spec_public @*/ private final int queue[] = new int[MAX];\n    \t\t//@ public invariant 0 <= rear && rear <= MAX;\n    \t\t//@ public invariant front == 0;\n    \t\t//@ public invariant queue.length == MAX;\n\n    \t\t//@ ensures front == 0 && rear == 0;\n    \t\tpublic /*@ pure @*/ Queue() \n    \t\t{ \n       \t\t\t front = rear = 0;  \n   \t\t} \n\n    \t\t/*@ public normal_behavior\n     \t\t  @ \trequires 0 <= rear && rear < MAX;\n     \t\t  @ \trequires !isFull();\n      \t   \t  @ \tassignable queue[*], rear;\n      \t\t  @ \tensures \\old (rear) == rear - 1;\n      \t\t  @ \tensures queue[rear-1] == data;\n\n      \t\t  @ also\n\n      \t\t  @      requires isFull();\n\t\t  @\t assignable \\nothing;\n      \t\t  @      signals_only IllegalArgumentException; @*/\n   \t\tpublic void enter(int data) \n    \t\t{ \n       \t\t\tif (!isFull()) { \n            \t\t\tqueue[rear] = data; \n            \t\t\trear++; \n        \t\t} else { \n            \t\t\tthrow new IllegalArgumentException(); \n        \t\t} \n    \t\t} \n\n    \t\t/*@ public normal_behavior\n      \t\t  @ \trequires !isEmpty();\n      \t\t  @ \told int tempQ[] = queue.clone();\n     \t \t  @ \tassignable queue[*], rear;\n      \t\t  @\tensures rear == \\old (rear - 1);\n      \t\t  @ \tensures \\result == \\old (queue[front]);\n      \t\t  @ \tensures (\\forall int i; 0 <= i && i < rear; queue[i] == tempQ[i+1]);\n\n      \t\t  @ also\n\n      \t\t  @ public exceptional_behavior\n     \t\t  @ \trequires isEmpty();\n\t\t  @\tassignable \\nothing;\n      \t\t  @     signals_only IllegalArgumentException; @*/\n    \t\tpublic int delete() \n    \t\t{ \n        \t\tif (!isEmpty()) { \n            \t\t\tint poll = queue[front];\n            \t\t\t//@ ghost int temp[] = queue.clone();\n            \t\t\tint i = 0;\n            \t\t\t/*@ maintaining (\\forall int j; 0 <= j && j < i; queue[j] == temp[j+1]);\n              \t\t  \t@ maintaining 0 <= i && i < rear;\n              \t\t\t@*/\n            \t\t\twhile (i < rear - 1) {\n                \t\t\t//@ assume queue[i+1] == temp[i+1];\n                \t\t\tqueue[i] = queue[i + 1];\n                \t\t\ti++;\n            \t\t\t}\n            \t\t\trear--;\n            \t\t\treturn poll; \n        \t\t} else {\n            \t\t\tthrow new IllegalArgumentException();\n        \t\t}\n    \t\t} \n\t\t\n    \t\t/*@ public normal_behavior\n      \t\t  @ \trequires !isEmpty();\n      \t\t  @ \tensures \\result == queue[front];\n\n      \t\t  @ also\n\n      \t\t  @ public exceptional_behavior\n      \t\t  @ \trequires isEmpty();\n      \t\t  @     signals_only IllegalArgumentException; \t\n      \t\t@*/\n    \t\tpublic /*@ pure @*/ int peek() \n    \t\t{ \n        \t\tif (!isEmpty()) { \n            \t\t\treturn queue[front]; \n        \t\t} else {\n            \t\t\tthrow new IllegalArgumentException(); \n        \t\t}\n    \t\t} \n\n   \t \t//@ public normal_behavior\n    \t\t//@   ensures \\result ==> \\exists int i; 0 <= i && i < rear; queue[i] == key;\n    \t\t//@   ensures !\\result ==> \\forall int i; 0 <= i && i < rear; queue[i] != key;\n    \t\tpublic /*@ pure @*/ boolean isContain(int key)\n    \t\t{\n        \t\tint index = 0;\n        \t\t//@ maintaining 0 <= index && index <= rear;\n        \t\t//@ maintaining \\forall int i; 0 <= i && i < index; queue[i] != key;\n        \t\twhile (index < rear) {\n        \t\t \tif (key == queue[index]) {\n        \t\t \t       return true;\n            \t\t\t}\n            \t\tindex++;\n    \t\t    \t}\n        \treturn false;\n    \t\t}\n\n    \t\t//@ public normal_behavior\n    \t\t//@   ensures 0 <= \\result && \\result < rear ==> queue[\\result] == key;\n    \t\t//@   ensures \\result == -1 ==> \\forall int i; 0 <= i && i < rear; queue[i] != key;\n    \t\tpublic /*@ pure @*/ int search(int key)\n    \t\t{\n        \t\tint index = 0;\n        \t\t//@ maintaining 0 <= index && index <= rear;\n        \t\t//@ maintaining \\forall int i; 0 <= i && i < index; queue[i] != key;\n        \t\twhile (index < rear) {\n            \t\t\tif (key == queue[index]) {\n                \t\t\treturn index;\n            \t\t\t}\n            \t\tindex++;\n        \t\t}\n        \treturn -1;\n    \t\t}\n\n    \t\t//@ public normal_behavior\n   \t\t//@   ensures \\result <==>  rear == front;\n   \t\tpublic /*@ pure @*/ boolean isEmpty() \n   \t\t{\n   \t\t     \treturn (getRear() == getFront());\n    \t\t}\n\n    \t\t//@ public normal_behavior\n    \t\t//@   ensures \\result <==>  MAX == rear;\n    \t\tpublic /*@ pure @*/ boolean isFull() \n    \t\t{\n    \t\t    \tif (MAX == getRear()) \n    \t\t        \treturn true;\n    \t\t    \telse\n    \t\t        \treturn false;\n    \t\t}\n\n    \t\t//@ public normal_behavior\n    \t\t//@   ensures rear == \\result;\n    \t\tpublic /*@ pure @*/ int size()\n    \t\t{\n    \t\t    \treturn rear;\n    \t\t}\n\n  \t\t//@ public normal_behavior\n  \t\t//@   ensures \\result == front;\n   \t\tpublic /*@ pure @*/ int getFront() \n    \t\t{\t\n       \t\t\treturn front; \n   \t\t}\n\n    \t\t//@ public normal_behavior\n    \t\t//@   ensures \\result == rear;\n    \t\tpublic /*@ pure @*/ int getRear() \n    \t\t{ \n        \t\treturn rear; \n    \t\t}\n\n    \t\t//@ public normal_behavior\n    \t\t//@   requires 0 <= i && i < rear;\n    \t\t//@   ensures \\result == queue[i];\n    \t\tpublic /*@ pure @*/ int getElem(int i) \n    \t\t{ \n        \t\treturn queue[i]; \n    \t\t}\n\t}; \n\n    \t/*@ requires 1 <= stack.top;\n      \t  @ requires Integer.MIN_VALUE <= stack.getElem(stack.top) + stack.getElem(stack.top - 1);\n     \t  @ requires stack.getElem(stack.top) + stack.getElem(stack.top - 1)  <= Integer.MAX_VALUE;\n      \t  @ assignable stack.top, stack.arr[*];\n      \t  @ ensures \\result == \\old (stack.getElem(stack.top) + stack.getElem(stack.top - 1));\n      \t  @ ensures stack.size() == \\old (stack.size() - 1);\n    \t@*/\n    \tpublic int stackPlus(Stack stack) \n    \t{\n\t\tstack.push(stack.pop() + stack.pop());\n\t\treturn stack.peek();\n    \t}\n\n    \t/*@ requires 1 <= stack.getTop();\n      \t  @ requires Integer.MIN_VALUE <= stack.getElem(stack.top) - stack.getElem(stack.top - 1);\n          @ requires stack.getElem(stack.top) - stack.getElem(stack.top - 1)  <= Integer.MAX_VALUE;\n          @ assignable stack.top, stack.arr[*];\n          @ ensures \\result == \\old (stack.getElem(stack.top) - stack.getElem(stack.top - 1));\n          @ ensures stack.size() == \\old (stack.size() - 1);\n    \t@*/\n    \tpublic int stackMinus(Stack stack) \n    \t{\n\t\tstack.push(stack.pop() - stack.pop());\n\t\treturn stack.peek();\n    \t}\n\n    \t/*@ requires 1 <= stack.top;\n      \t  @ requires stack.getElem(stack.top - 1) != 0;\n      \t  @ requires Integer.MIN_VALUE <= stack.getElem(stack.top) / stack.getElem(stack.top - 1);\n      \t  @ requires stack.getElem(stack.top) / stack.getElem(stack.top - 1)  <= Integer.MAX_VALUE;\n      \t  @ assignable stack.top, stack.arr[*];\n      \t  @ ensures \\result == \\old (stack.getElem(stack.top) / stack.getElem(stack.top - 1));\n      \t  @ ensures stack.size() == \\old (stack.size() - 1);\n    \t@*/\n    \tpublic int stackDivision(Stack stack) \n    \t{\n\t\tstack.push(stack.pop() / stack.pop());\n\t\treturn stack.peek();\n    \t}\n\n    \t/*@ requires 1 <= stack.top && stack.getElem(stack.top - 1) != 0;\n      \t  @ requires Integer.MIN_VALUE <= stack.getElem(stack.top) % stack.getElem(stack.top - 1);\n      \t  @ requires stack.getElem(stack.top) % stack.getElem(stack.top - 1)  <= Integer.MAX_VALUE;\n      \t  @ assignable stack.top, stack.arr[*];\n      \t  @ ensures \\result == \\old (stack.getElem(stack.top) % stack.getElem(stack.top - 1));\n      \t  @ ensures stack.size() == \\old (stack.size() - 1);\n    \t@*/\n    \tpublic int stackModulus(Stack stack) \n    \t{\n\t\tstack.push(stack.pop() % stack.pop());\n \t\treturn stack.peek();\n    \t}\n\n    \t/*@ requires 2 <= Q.rear;\n          @ requires Integer.MIN_VALUE <= Q.getElem(Q.front) + Q.getElem(Q.front + 1);\n      \t  @ requires Q.getElem(Q.front) + Q.getElem(Q.front + 1)  <= Integer.MAX_VALUE;\n      \t  @ assignable Q.rear, Q.queue[*];\n      \t  @ ensures \\result == \\old (Q.getElem(Q.front) + Q.getElem(Q.front + 1));\n      \t  @ ensures Q.size() == \\old (Q.size() - 1);\n    \t@*/\n    \tpublic int QPlus(Queue Q) \n    \t{\n\t\tQ.enter(Q.delete() + Q.delete());\n\t\treturn Q.getElem(Q.getRear() - 1);\n    \t}\n\n    \t/*@ requires 2 <= Q.rear;\n      \t  @ requires Integer.MIN_VALUE <= Q.getElem(Q.front) - Q.getElem(Q.front + 1);\n      \t  @ requires Q.getElem(Q.front) - Q.getElem(Q.front + 1)  <= Integer.MAX_VALUE;\n          @ assignable Q.rear, Q.queue[*];\n          @ ensures \\result == \\old (Q.getElem(Q.front) - Q.getElem(Q.front + 1));\n          @ ensures Q.size() == \\old (Q.size() - 1);\n    \t@*/\n    \tpublic int QMinus(Queue Q) \n    \t{\n\t\tQ.enter(Q.delete() - Q.delete());\n\t\treturn Q.getElem(Q.getRear() - 1);\n    \t}\n\n    \t/*@ requires 2 <= Q.rear && Q.getElem(Q.front + 1) != 0;\n      \t  @ requires Integer.MIN_VALUE <= Q.getElem(Q.front) / Q.getElem(Q.front + 1);\n      \t  @ requires Q.getElem(Q.front) / Q.getElem(Q.front + 1)  <= Integer.MAX_VALUE;\n      \t  @ assignable Q.rear, Q.queue[*];\n      \t  @ ensures \\result == \\old (Q.getElem(Q.front) / Q.getElem(Q.front + 1));\n      \t  @ ensures Q.size() == \\old (Q.size() - 1);\n    \t@*/\n    \tpublic int QDivision(Queue Q) \n    \t{\n\t\tQ.enter(Q.delete() / Q.delete());\n\t\treturn Q.getElem(Q.getRear() - 1);\n    \t}\n\n    \t/*@ requires 2 <= Q.rear && Q.getElem(Q.front + 1) != 0;\n      \t  @ requires Integer.MIN_VALUE <= Q.getElem(Q.front) % Q.getElem(Q.front + 1);\n      \t  @ requires Q.getElem(Q.front) % Q.getElem(Q.front + 1)  <= Integer.MAX_VALUE;\n          @ assignable Q.rear, Q.queue[*];\n          @ ensures \\result == \\old (Q.getElem(Q.front) % Q.getElem(Q.front + 1));\n          @ ensures Q.size() == \\old (Q.size() - 1);\n        @*/\n        public int QModulus(Queue Q) \n    \t{\n\t\tQ.enter(Q.delete() % Q.delete());\n\t\treturn Q.getElem(Q.getRear() - 1);\n    \t}\t\n\t\n\n    \t/*@ requires 1 <= Q.rear && 1 <= stack.top;\n      \t  @ requires Q.peek() + stack.peek() <= Integer.MAX_VALUE;\n          @ requires Integer.MIN_VALUE <= Q.peek() + stack.peek();\n          @ ensures \\result == Q.peek() + stack.peek();\n    \t@*/\n\n    \tpublic /*@ pure @*/ int plusQStack(Queue Q, Stack stack) \n    \t{\n\t\treturn Q.peek() + stack.peek();\n    \t}\n\n    \t/*@ requires 1 <= Q.rear && 1 <= stack.top;\n      \t  @ requires Q.peek() - stack.peek() <= Integer.MAX_VALUE;\n      \t  @ requires Integer.MIN_VALUE <= Q.peek() - stack.peek();\n      \t  @ ensures \\result == Q.peek() - stack.peek();\n    \t@*/\n    \tpublic /*@ pure @*/ int minusQStack(Queue Q, Stack stack) \n    \t{\n\t\treturn Q.peek() - stack.peek();\n    \t}\n\n    \t/*@ requires 1 <= Q.rear && 1 <= stack.top;\n      \t  @ requires stack.peek() != 0;\n          @ requires Q.peek() / stack.peek() <= Integer.MAX_VALUE;\n          @ requires Integer.MIN_VALUE <= Q.peek() / stack.peek();\n          @ ensures \\result == Q.peek() / stack.peek();\n    \t@*/\n    \tpublic /*@ pure @*/ int qDivideStack(Queue Q, Stack stack) \n    \t{\n\t\treturn Q.peek() / stack.peek();\n    \t}\n\n    \t/*@ requires 1 <= Q.rear && 1 <= stack.top;\n      \t  @ requires Q.peek() != 0;\n      \t  @ requires stack.peek() / Q.peek() <= Integer.MAX_VALUE;\n      \t  @ requires Integer.MIN_VALUE <= stack.peek() / Q.peek();\n      \t  @ ensures \\result == stack.peek() / Q.peek();\n    \t@*/\n    \tpublic /*@ pure @*/ int stackDivideQ(Queue Q, Stack stack) \n    \t{\n\t\treturn  stack.peek()/Q.peek();\n    \t}\t\n\n       /*@ requires 1 <= Q.rear && 1 <= stack.top;\n         @ requires stack.peek() != 0;\n         @ requires Q.peek() % stack.peek() <= Integer.MAX_VALUE;\n         @ requires Integer.MIN_VALUE <= Q.peek() % stack.peek();\n         @ ensures \\result == Q.peek() % stack.peek();\n       @*/\n    \tpublic /*@ pure @*/ int qModulusStack(Queue Q, Stack stack) \n    \t{\n\t\treturn Q.peek() % stack.peek();\n    \t}\n\n    \t/*@ requires 1 <= Q.rear && 1 <= stack.top;\n      \t  @ requires Q.peek() != 0;\n      \t  @ requires stack.peek() % Q.peek() <= Integer.MAX_VALUE;\n      \t  @ requires Integer.MIN_VALUE <= stack.peek() % Q.peek();\n      \t  @ ensures \\result == stack.peek() % Q.peek();\n    \t@*/\n    \tpublic /*@ pure @*/ int stackModulusQ(Queue Q, Stack stack) \n    \t{\n\t\treturn  stack.peek() % Q.peek();\n    \t}\n\t\n\t/*@ requires 0 <= op && op < 9;\n    \t  @ {|\n\t  @ \trequires op == 0 && !stack.isFull();\n\t  @\tassignable stack.top, stack.arr[*];\n\t  @ \tensures stack.peek() == input && stack.top == \\old (stack.top + 1) && \\result == 0;\n\t  @ also\n\t  @\trequires op == 1 && !stack.isEmpty();\n\t  @\tassignable stack.top, stack.arr[stack.top+1];\n\t  @\tensures \\result == \\old (stack.getElem(stack.top));\n\t  @\tensures stack.top == \\old (stack.top - 1);\n\t  @ also\n\t  @\trequires op == 2;\n\t  @\tensures 0 <= \\result && \\result <= stack.top ==> input == stack.getElem(\\result);\n\t  @\tensures \\result == -1 ==>  \\forall int i; 0 <= i && i <= stack.top; stack.arr[i] != input;\n\t  @ also\n\t  @\trequires op == 3;\n\t  @\tensures \\result == 1 ==> \\exists int i; 0 <= i && i <= stack.top; stack.arr[i] == input;\n\t  @\tensures \\result == 0 ==> \\forall int i; 0 <= i && i <= stack.top; stack.arr[i] != input;\n\t  @ also\n\t  @ \trequires op == 4 && 1 <= stack.top;\n\t  @ \trequires Integer.MIN_VALUE <= stack.getElem(stack.top) + stack.getElem(stack.top - 1);\n\t  @ \trequires stack.getElem(stack.top) + stack.getElem(stack.top - 1)  <= Integer.MAX_VALUE;\n\t  @\tassignable stack.top, stack.arr[*];\n\t  @\tensures \\result == \\old (stack.getElem(stack.top) + stack.getElem(stack.top - 1));\n\t  @\tensures stack.top == \\old (stack.top - 1);\n\t  @ also\n\t  @ \trequires op == 5 && 1 <= stack.top;\n\t  @ \trequires Integer.MIN_VALUE <= stack.getElem(stack.top) - stack.getElem(stack.top - 1);\n\t  @ \trequires stack.getElem(stack.top) - stack.getElem(stack.top - 1)  <= Integer.MAX_VALUE;\n\t  @\tassignable stack.top, stack.arr[*];\n\t  @\tensures \\result == \\old (stack.getElem(stack.top) - stack.getElem(stack.top - 1));\n\t  @\tensures stack.top == \\old (stack.top - 1);\n\t  @ also\n\t  @ \trequires op == 6 && 1 <= stack.top;\n\t  @ \trequires stack.getElem(stack.top - 1) != 0;\n\t  @ \trequires Integer.MIN_VALUE <= stack.getElem(stack.top) / stack.getElem(stack.top - 1);\n\t  @ \trequires stack.getElem(stack.top) / stack.getElem(stack.top - 1)  <= Integer.MAX_VALUE;\n\t  @\tassignable stack.top, stack.arr[*];\n\t  @\tensures \\result == \\old (stack.getElem(stack.top) / stack.getElem(stack.top - 1));\n\t  @\tensures stack.top == \\old (stack.top - 1);\t\t\n\t  @ also\n\t  @ \trequires op == 7 && 1 <= stack.top && stack.getElem(stack.top - 1) != 0;\n\t  @ \trequires Integer.MIN_VALUE <= stack.getElem(stack.top) % stack.getElem(stack.top - 1);\n\t  @ \trequires stack.getElem(stack.top) % stack.getElem(stack.top - 1)  <= Integer.MAX_VALUE;\n\t  @ \tassignable stack.top, stack.arr[*];\n\t  @ \tensures \\result == \\old (stack.getElem(stack.top) % stack.getElem(stack.top - 1));\n\t  @ \tensures stack.size() == \\old (stack.size() - 1);\n\t  @ also\n\t  @ \trequires op == 8;\n\t  @\tensures \\result == stack.top + 1;\n        @ |}\t\n    \t@*/\n    \tpublic int driverStack(Stack stack, int op, int input) \n    \t{\n\t\tint output = 0;\n\t\tswitch (op) {\n          \t\tcase 0:\n            \t\tstack.push(input);\n\t\t\tbreak;\n\n\t\t\tcase 1:\n            \t\toutput = stack.pop();\n\t\t\tbreak;\n\n\t\t\tcase 2:\n            \t\toutput = stack.search(input);\n\t\t\tbreak;\n\n\t\t\tcase 3:\n            \t\toutput = (stack.isContain(input)) ? 1 : 0;\n\t\t\tbreak;\n\n\t\t\tcase 4:\n            \t\toutput = stackPlus(stack);\n\t\t\tbreak;\n\n\t\t\tcase 5:\n            \t\toutput = stackMinus(stack);\n               \t\t break;\n\n\t\t\tcase 6:\n            \t\toutput = stackDivision(stack);\n               \t\tbreak;\n\n\t\t\tcase 7:\n\t\t\toutput = stackModulus(stack);\n\t\t\tbreak;\n\n\t\t\tdefault:\n            \t\toutput = stack.size();\n\t\t\tbreak;\n\t \t}\n\t\treturn output;\n    \t}\n\n    \t /*@ requires 0 <= op && op < 9;\n       \t   @ {|\n\t   @ \trequires op == 0 && 0 <= q.rear && q.rear < q.MAX;\n\t   @ \trequires !q.isFull(); \n\t   @ \tassignable q.queue[*], q.rear;\n\t   @\tensures \\old (q.rear) == q.rear - 1;\n\t   @\tensures q.queue[q.rear-1] == input && \\result == 0;\t\n\t   @ also\n\t   @ \trequires op == 1 && !q.isEmpty();\n           @ \told int tempQ[] = q.queue.clone();\n\t   @ \tassignable q.queue[*], q.rear;\n\t   @ \tensures q.rear == \\old (q.rear - 1);\n\t   @ \tensures \\result == \\old (q.queue[q.front]);\n\t   @ \tensures (\\forall int i; 0 <= i && i < q.rear; q.queue[i] == tempQ[i+1]);\n\t   @ also\n\t   @\trequires op == 2;\n\t   @ \tensures 0 <= \\result && \\result < q.rear ==> q.queue[\\result] == input;\n\t   @ \tensures \\result == -1 ==> \\forall int i; 0 <= i && i < q.rear; q.queue[i] != input;\n\t   @ also\n\t   @ \trequires op == 3;\n\t   @ \tensures \\result == 1 ==> \\exists int i; 0 <= i && i < q.rear; q.queue[i] == input;\n\t   @ \tensures \\result == 0 ==> \\forall int i; 0 <= i && i < q.rear; q.queue[i] != input;\n\t   @ also\n\t   @ \trequires op == 4 && 2 <= q.rear;\n\t   @ \trequires Integer.MIN_VALUE <= q.getElem(q.front) + q.getElem(q.front + 1);\n\t   @ \trequires q.getElem(q.front) + q.getElem(q.front + 1)  <= Integer.MAX_VALUE;\n\t   @ \tassignable q.rear, q.queue[*];\n\t   @ \tensures \\result == \\old (q.getElem(q.front) + q.getElem(q.front + 1));\n\t   @ \tensures q.size() == \\old (q.size() - 1);\n\t   @ also\n\t   @\trequires op == 5 && 2 <= q.getRear();\n\t   @ \trequires Integer.MIN_VALUE <= q.getElem(q.front) - q.getElem(q.front + 1);\n\t   @ \trequires q.getElem(q.front) - q.getElem(q.front + 1)  <= Integer.MAX_VALUE;\n\t   @ \tassignable q.rear, q.queue[*];\n\t   @ \tensures \\result == \\old (q.getElem(q.front) - q.getElem(q.front + 1));\n\t   @ \tensures q.size() == \\old (q.size() - 1);\n\t   @ also\n\t   @\trequires op == 6 && 2 <= q.rear && q.getElem(q.front + 1) != 0;\n\t   @ \trequires Integer.MIN_VALUE <= q.getElem(q.front) / q.getElem(q.front + 1);\n\t   @ \trequires q.getElem(q.front) / q.getElem(q.front + 1)  <= Integer.MAX_VALUE;\n\t   @ \tassignable q.rear, q.queue[*];\n\t   @ \tensures \\result == \\old (q.getElem(q.front) / q.getElem(q.front + 1));\n\t   @ \tensures q.size() == \\old (q.size() - 1);\n\t   @ also\n\t   @\trequires op == 7 && 2 <= q.rear && q.getElem(q.front + 1) != 0;\n\t   @ \trequires Integer.MIN_VALUE <= q.getElem(q.front) % q.getElem(q.front + 1);\n\t   @ \trequires q.getElem(q.front) % q.getElem(q.front + 1)  <= Integer.MAX_VALUE;\n\t   @ \tassignable q.rear, q.queue[*];\n\t   @ \tensures \\result == \\old (q.getElem(q.front) % q.getElem(q.front + 1));\n\t   @ \tensures q.size() == \\old (q.size() - 1);\n\t   @ also\n\t   @ \trequires op == 8;\n\t   @\tensures \\result == q.rear;\t\n         @ |}\n   \t @*/\n   \t public int driverQueue(Queue q, int op, int input)\n    \t {\n\t\tint output = 0;\n\t\tswitch (op) {\n\t\t\tcase 0:\n           \t\tq.enter(input);\n                \tbreak;\n\n\t\t\tcase 1:\n            \t\toutput = q.delete();\n                \tbreak;\n\n\t\t\tcase 2:\n            \t\toutput = q.search(input);\n                \tbreak;\n\n\t\t\tcase 3:\n            \t\toutput = q.isContain(input) ? 1 : 0;\n               \t\tbreak;\n\n\t\t\tcase 4:\n            \t\toutput = QPlus(q);\n                \tbreak;\n\n\t\t\tcase 5:\n            \t\toutput = QMinus(q);\n                \tbreak;\n\n\t\t\tcase 6:\n            \t\toutput = QDivision(q);\n                \tbreak;\n\n\t\t\tcase 7:\n\t\t\toutput = QModulus(q);\n\t\t\tbreak;\n\n\t\t\tdefault:\n            \t\toutput = q.size();\n                \tbreak;\n\t\t}\n\t\treturn output;\n    \t}\n\n    \t/*@ requires 0 <= op && op < 6;\n      \t  @ {|\n\t  @\trequires op == 0 && 1 <= q.rear && 1 <= stack.top;\n\t  @ \trequires q.peek() + stack.peek() <= Integer.MAX_VALUE;\n\t  @ \trequires Integer.MIN_VALUE <= q.peek() + stack.peek();\n\t  @ \tensures \\result == q.peek() + stack.peek();\n\t  @ also\n\t  @\trequires op == 1 && 1 <= q.rear && 1 <= stack.top;\n\t  @ \trequires q.peek() - stack.peek() <= Integer.MAX_VALUE;\n\t  @ \trequires Integer.MIN_VALUE <= q.peek() - stack.peek();\n\t  @ \tensures \\result == q.peek() - stack.peek();\n\t  @ also\n\t  @\trequires op == 2 && 1 <= q.rear && 1 <= stack.top;\n\t  @ \trequires stack.peek() != 0;\n\t  @ \trequires q.peek() / stack.peek() <= Integer.MAX_VALUE;\n\t  @ \trequires Integer.MIN_VALUE <= q.peek() / stack.peek();\n\t  @ \tensures \\result == q.peek() / stack.peek();\n\t  @ also\n\t  @\trequires op == 3 && 1 <= q.rear && 1 <= stack.top;\n\t  @ \trequires q.peek() != 0;\n\t  @ \trequires stack.peek() / q.peek() <= Integer.MAX_VALUE;\n\t  @ \trequires Integer.MIN_VALUE <= stack.peek() / q.peek();\n\t  @ \tensures \\result == stack.peek() / q.peek();\n\t  @ also\n\t  @\trequires op == 4 && 1 <= q.rear && 1 <= stack.top;\n\t  @ \trequires stack.peek() != 0;\n\t  @ \trequires q.peek() % stack.peek() <= Integer.MAX_VALUE;\n\t  @ \trequires Integer.MIN_VALUE <= q.peek() % stack.peek();\n\t  @ \tensures \\result == q.peek() % stack.peek();\n\t  @ also\n\t  @\trequires op == 5 && 1 <= q.rear && 1 <= stack.top;\n\t  @ \trequires q.peek() != 0;\n\t  @ \trequires stack.peek() % q.peek() <= Integer.MAX_VALUE;\n\t  @ \trequires Integer.MIN_VALUE <= stack.peek() % q.peek();\n\t  @ \tensures \\result == stack.peek() % q.peek();\n        @ |}\n        @*/\n    \tpublic int driverQStack(Stack stack, Queue q, int op) \n    \t{\n\t\tStackQueue sq = new StackQueue();\n\t\tint output = 0;\n\t\tswitch (op) {\n\t\t\tcase 0:\n          \t\toutput = sq.plusQStack(q, stack);\n                \tbreak;\n\n\t\t\tcase 1:\n            \t\toutput = sq.minusQStack(q, stack);\n               \t\tbreak;\n\n\t\t\tcase 2:\n            \t\toutput = sq.qDivideStack(q, stack);\n                \tbreak;\n\n\t\t\tcase 3:\n\t\t\toutput = sq.stackDivideQ(q, stack);\n\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\toutput = sq.qModulusStack(q, stack);\n\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\toutput = sq.stackModulusQ(q, stack);\n\t\t\tbreak;\n\t\t}\n\t\treturn output;\n    \t }\n}',
  },
  {
    className: 'StrPalindrome',
    testcase:
      'public class StrPalindrome {\n   private  String reverse = "";\n   \n   public boolean isPalindrome(String str) {\n      \n      int length = str.length();\n\n      for (int i = length - 1; 0 <= i; i--) {\n         reverse = reverse + str.charAt(i);\n\t \n      }\n      \n      return reverse.equals(str);\n   }\n}',
    groundTruth:
      'public class StrPalindrome {\n   private /*@ spec_public @*/ String reverse = "";\n   /*@ public normal_behavior\n     @    requires (\\forall int i; 0 <= i && i < str.length(); (int)Character.MIN_VALUE <= (int)str.charAt(i) && (int)str.charAt(i) <= (int)Character.MAX_VALUE);\n     @    assignable reverse;\n     @    ensures \\result <==> reverse.equals(str); @*/\n   public boolean isPalindrome(String str) {\n      \n      int length = str.length();\n\t\n      //@ ghost int i_counter;\n      //@ set i_counter = 0;\n      //@ maintaining -1 <= i && i < str.length(); \n      //@ decreases i;\n      //@ maintaining i_counter + i + 1 == length;\n      for (int i = length - 1; 0 <= i; i--) {\n         reverse = reverse + str.charAt(i);\n\t //@ set i_counter = i_counter + 1;\n       }\n      //@ assert i_counter == length;   \n      return reverse.equals(str);\n   }\n}',
  },
  {
    className: 'StudentEnrollment',
    testcase:
      'public class StudentEnrollment {\n    public static final int costPerCredit = 200;  \n    public static final int totalCredits = 120;\n    public static final int maxSemesterCredits = 20;\n\n     private String firstName;\n     private String lastName;\n     private int passedCredits;  \n     private int enrollmentCredits; \n    \n     private int tuitionBalance;\n    \n     private boolean lateRegistration;\n\t\n    \n    StudentEnrollment( String firstName,\n               String lastName) \n    {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n\n    \n    public void setTuitionBalance(int tuitionBalance)\n    {\n\tint maxTuitionBalance = maxSemesterCredits * costPerCredit + maxSemesterCredits * ((costPerCredit/100)*6);\n\tif (maxTuitionBalance < tuitionBalance) {\n                throw new IllegalArgumentException();\n\t} else {\n\t\tthis.tuitionBalance = tuitionBalance;\n\t}\n    }\n\t\n    \n    public void setPassedCredits(int passedCredits)\n    {\n        if (0 <= passedCredits && passedCredits <= totalCredits) {\n            this.passedCredits = passedCredits;\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    \n    public void setEnrollmentCredits(int enrollmentCredits)\n    {\n        if (0 <= enrollmentCredits && enrollmentCredits <= maxSemesterCredits) {\n            this.enrollmentCredits = enrollmentCredits;\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    \n    \n    \n    public void setLateRegistration (boolean lateRegistration) \n    {\n        this.lateRegistration = lateRegistration;\n    }\n\n    \n    \n    public  int getTuition() \n    {\n        return this.tuitionBalance;\n    }\n\n    \n    \n    public  int getEnrollmentCredits() \n    {\n        return this.enrollmentCredits;\n    }\n\n    \n    \n    public  int getPassedCredits() \n    {\n        return this.passedCredits;\n    }\n\n    \n    \n    public  boolean getLateRegistrations() \n    {\n        return this.lateRegistration;\n    }\n\n    \n    \n    public  String getFirstName()\n    {\n        return this.firstName;\n    }\n\n    \n    \n    public  String getLastName()\n    {\n        return this.lastName;\n    } \n\n    \n    \n    public  boolean registrationPermission() \n    {\n        return (this.tuitionBalance <= 0);\n    }\n\n    \n    \n    public  boolean validPayment(int payment)\n    {\n        return (0 < payment);\n    }\n\n    \n    public void regularEnrollment()\n    {\n\tif (registrationPermission()) {\n        \tint cost = getEnrollmentCredits() * costPerCredit;\n        \ttuitionBalance = getTuition() + cost;\n\t} else { \n\t\tthrow new IllegalArgumentException();\n        }\n    }\n\n    \n    public void lateEnrollment() \n    {\n\tif (registrationPermission()) {\n        \tint latePerCredit = (costPerCredit/100)*6;\n        \tint cost;\n        \tcost = getEnrollmentCredits() * costPerCredit + getEnrollmentCredits() * latePerCredit;\n        \ttuitionBalance = getTuition() + cost;\n\t} else { \n\t\tthrow new IllegalArgumentException();\n        }\n    }\n\n    \n    public void enroll() \n    {\n        if (getLateRegistrations())\n            lateEnrollment(); \n        else \n            regularEnrollment();\n    }\n\n    \n    private  void payTuitionWithDebitCard(int payment) \n    {\n        if (validPayment(payment)) {\n            tuitionBalance -= payment;\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    \n    private  void payTuitionWithCreditCard(int payment) \n    {\n        int penalty;\n        penalty = (payment/100)*2;\n        payment -= penalty;\n        if (validPayment(payment)) {\n            tuitionBalance -= payment;\n\t} else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    \n    public void pay(int payment, boolean debit) \n    {\n        if (debit) {\n            payTuitionWithDebitCard(payment);\n        } else {\n            payTuitionWithCreditCard(payment);\n        }\n    }\n\n    \n    public void enrollmentProcess(int passedCredits, int semesterCredits, int payment, int initialBalance, boolean lateRegistration, boolean debit, boolean option) \n     {\n        String familyName = getLastName();\n        String firstName = getFirstName();\n        setTuitionBalance(initialBalance);\n        setPassedCredits(passedCredits);\n        setEnrollmentCredits(semesterCredits);\n\tsetLateRegistration(lateRegistration);\n\n        if (option) {\n\t\tif (registrationPermission()) {\n\t\t\tenroll();\n                }\n\t} else {\n\t\tpay(payment, debit);\n\t}\n     }\n}',
    groundTruth:
      'public class StudentEnrollment {\n    public static final int costPerCredit = 200;  \n    public static final int totalCredits = 120;\n    public static final int maxSemesterCredits = 20;\n\n    /*@ spec_public @*/ private String firstName;\n    /*@ spec_public @*/ private String lastName;\n    /*@ spec_public @*/ private int passedCredits;  //number of credits which are passed during previous semesters\n    /*@ spec_public @*/ private int enrollmentCredits; //number of credits which will get this semester\n    //@ public invariant 0 <= enrollmentCredits && enrollmentCredits <= maxSemesterCredits;\n    /*@ spec_public @*/ private int tuitionBalance;\n    /*@ public invariant tuitionBalance <= \n                         maxSemesterCredits * costPerCredit \n                         + (maxSemesterCredits * ((costPerCredit/100)*6)); @*/\n    /*@ spec_public @*/ private boolean lateRegistration;\n\t\n    /*@ ensures this.firstName.equals(firstName);\n      @ ensures this.lastName.equals(lastName);\n      @ ensures passedCredits == 0 && enrollmentCredits == 0;\n      @ ensures tuitionBalance == 0; @*/\n    StudentEnrollment(/*@ non_null @*/ String firstName,\n              /*@ non_null @*/ String lastName) \n    {\n        this.firstName = firstName;\n        this.lastName = lastName;\n    }\n\n    /*@     public normal_behavior\n      @   \trequires tuitionBalance <= maxSemesterCredits * costPerCredit + maxSemesterCredits * ((costPerCredit/100)*6);\n      @         assignable this.tuitionBalance;\n      @   \tensures this.tuitionBalance == tuitionBalance; \n      @ also\n      @     public exceptional_behavior\n      @\t\trequires maxSemesterCredits * costPerCredit + maxSemesterCredits * ((costPerCredit/100)*6) < tuitionBalance;\n      @ \tassignable \\nothing;\n      @\t\tsignals_only IllegalArgumentException;\n      @   \tsignals(IllegalArgumentException) this.tuitionBalance == \\old (this.tuitionBalance); @*/\n    public void setTuitionBalance(int tuitionBalance)\n    {\n\tint maxTuitionBalance = maxSemesterCredits * costPerCredit + maxSemesterCredits * ((costPerCredit/100)*6);\n\tif (maxTuitionBalance < tuitionBalance) {\n                throw new IllegalArgumentException();\n\t} else {\n\t\tthis.tuitionBalance = tuitionBalance;\n\t}\n    }\n\t\n    /*@      public normal_behavior\n      @   \trequires 0 <= passedCredits && passedCredits <= totalCredits;\n      @   \tassignable this.passedCredits;\n      @   \tensures this.passedCredits == passedCredits;\n      @ also\n      @      public exceptional_behavior\n      @   \trequires passedCredits < 0 || totalCredits < passedCredits;\n      @   \tassignable \\nothing;\n      @   \tsignals_only IllegalArgumentException; @*/\n    public void setPassedCredits(int passedCredits)\n    {\n        if (0 <= passedCredits && passedCredits <= totalCredits) {\n            this.passedCredits = passedCredits;\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    /*@      public normal_behavior\n      @   \trequires 0 <= enrollmentCredits && enrollmentCredits <= maxSemesterCredits;\n      @   \tassignable this.enrollmentCredits;\n      @   \tensures this.enrollmentCredits == enrollmentCredits;\n      @ also\n      @      public exceptional_behavior\n      @   \trequires enrollmentCredits < 0 || maxSemesterCredits < enrollmentCredits;\n      @   \tassignable \\nothing;\n      @   \tsignals_only IllegalArgumentException; @*/\n    public void setEnrollmentCredits(int enrollmentCredits)\n    {\n        if (0 <= enrollmentCredits && enrollmentCredits <= maxSemesterCredits) {\n            this.enrollmentCredits = enrollmentCredits;\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    //@ public normal_behavior\n    //@   assignable this.lateRegistration;\n    //@   ensures this.lateRegistration == lateRegistration;\n    public void setLateRegistration (boolean lateRegistration) \n    {\n        this.lateRegistration = lateRegistration;\n    }\n\n    //@ public normal_behavior\n    //@   ensures \\result == this.tuitionBalance;\n    public /*@ pure @*/ int getTuition() \n    {\n        return this.tuitionBalance;\n    }\n\n    //@ public normal_behavior\n    //@   ensures \\result == this.enrollmentCredits;\n    public /*@ pure @*/ int getEnrollmentCredits() \n    {\n        return this.enrollmentCredits;\n    }\n\n    //@ public normal_behavior\n    //@   ensures \\result == this.passedCredits;\n    public /*@ pure @*/ int getPassedCredits() \n    {\n        return this.passedCredits;\n    }\n\n    //@ public normal_behavior\n    //@   ensures \\result == this.lateRegistration;\n    public /*@ pure @*/ boolean getLateRegistrations() \n    {\n        return this.lateRegistration;\n    }\n\n    //@ public normal_behavior\n    //@   ensures \\result.equals(this.firstName);\n    public /*@ pure @*/ String getFirstName()\n    {\n        return this.firstName;\n    }\n\n    //@ public normal_behavior\n    //@   ensures \\result.equals(this.lastName);\n    public /*@ pure @*/ String getLastName()\n    {\n        return this.lastName;\n    } \n\n    //@ public normal_behavior\n    //@   ensures \\result <==> (tuitionBalance <= 0);\n    public /*@ pure @*/ boolean registrationPermission() \n    {\n        return (this.tuitionBalance <= 0);\n    }\n\n    //@ public normal_behavior\n    //@   ensures \\result <==> (0 < payment);\n    public /*@ pure @*/ boolean validPayment(int payment)\n    {\n        return (0 < payment);\n    }\n\n    /*@      public normal_behavior\n      @   \trequires registrationPermission();\n      @   \trequires this.tuitionBalance + maxSemesterCredits * costPerCredit <= Integer.MAX_VALUE;\n      @   \tassignable this.tuitionBalance;\n      @   \tensures this.tuitionBalance == \\old(tuitionBalance + enrollmentCredits * costPerCredit);\n      @ also\n      @      public exceptional_behavior\n      @   \trequires !registrationPermission();\n      @   \tassignable \\nothing;\n      @   \tsignals_only IllegalArgumentException; @*/\n    public void regularEnrollment()\n    {\n\tif (registrationPermission()) {\n        \tint cost = getEnrollmentCredits() * costPerCredit;\n        \ttuitionBalance = getTuition() + cost;\n\t} else { \n\t\tthrow new IllegalArgumentException();\n        }\n    }\n\n    /*@      public normal_behavior\n      @   \told int latePerCredit = (costPerCredit/100)*6;\n      @   \trequires registrationPermission();\n      @   \trequires this.tuitionBalance + maxSemesterCredits * costPerCredit + maxSemesterCredits * latePerCredit <= Integer.MAX_VALUE;\n      @   \tassignable this.tuitionBalance;\n      @   \tensures this.tuitionBalance == \\old (tuitionBalance) + enrollmentCredits * costPerCredit + enrollmentCredits * latePerCredit;\n      @ also\n      @      public exceptional_behavior\n      @   \trequires !registrationPermission();\n      @   \tassignable \\nothing;\n      @   \tsignals_only IllegalArgumentException; @*/\n    public void lateEnrollment() \n    {\n\tif (registrationPermission()) {\n        \tint latePerCredit = (costPerCredit/100)*6;\n        \tint cost;\n        \tcost = getEnrollmentCredits() * costPerCredit + getEnrollmentCredits() * latePerCredit;\n        \ttuitionBalance = getTuition() + cost;\n\t} else { \n\t\tthrow new IllegalArgumentException();\n        }\n    }\n\n    /*@      public normal_behavior\n      @ \trequires lateRegistration;\n      @ \told int latePerCredit = (costPerCredit/100)*6;\n      @ \trequires registrationPermission();\n      @ \trequires this.tuitionBalance + maxSemesterCredits * costPerCredit + maxSemesterCredits * latePerCredit <= Integer.MAX_VALUE;\n      @ \tassignable this.tuitionBalance;\n      @ \tensures this.tuitionBalance == \\old (tuitionBalance + enrollmentCredits * costPerCredit) + enrollmentCredits * latePerCredit;\n      @ also\n      @      public normal_behavior\n      @   \trequires !lateRegistration;\n      @   \trequires registrationPermission();\n      @   \trequires this.tuitionBalance + maxSemesterCredits * costPerCredit <= Integer.MAX_VALUE;\n      @   \tassignable this.tuitionBalance;\n      @   \tensures this.tuitionBalance == \\old (tuitionBalance + enrollmentCredits * costPerCredit); @*/\n    public void enroll() \n    {\n        if (getLateRegistrations())\n            lateEnrollment(); \n        else \n            regularEnrollment();\n    }\n\n    /*@      public normal_behavior\n      @   \trequires validPayment(payment);\n      @  \trequires Integer.MIN_VALUE <= tuitionBalance - payment;\n      @   \tassignable tuitionBalance;\n      @   \tensures tuitionBalance == \\old(tuitionBalance - payment);\n      @ also\n      @      public exceptional_behavior\n      @   \trequires !validPayment(payment);\n      @   \tassignable \\nothing;\n      @   \tsignals_only IllegalArgumentException; @*/\n    private /*@ spec_public @*/ void payTuitionWithDebitCard(int payment) \n    {\n        if (validPayment(payment)) {\n            tuitionBalance -= payment;\n        } else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    /*@      public normal_behavior\n      @   \told int penalty = (payment/100)*2;\n      @   \told int _payment = payment - penalty;\n      @   \trequires validPayment(_payment);\n      @   \trequires Integer.MIN_VALUE <= tuitionBalance - _payment;\n      @   \tassignable tuitionBalance;\n      @   \tensures tuitionBalance == \\old(tuitionBalance - _payment);\n      @ also\n      @      public exceptional_behavior\n      @   \told int penalty = (payment/100)*2;\n      @   \told int _payment = payment - penalty;\n      @   \trequires !validPayment(_payment);\n      @   \tassignable \\nothing;\n      @   \tsignals_only IllegalArgumentException; @*/\n    private /*@ spec_public @*/ void payTuitionWithCreditCard(int payment) \n    {\n        int penalty;\n        penalty = (payment/100)*2;\n        payment -= penalty;\n        if (validPayment(payment)) {\n            tuitionBalance -= payment;\n\t} else {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    /*@      public normal_behavior\n      @   \trequires debit;\n      @   \trequires validPayment(payment);\n      @   \trequires Integer.MIN_VALUE <= tuitionBalance - payment;\n      @   \tassignable this.tuitionBalance;\n      @   \tensures tuitionBalance == \\old (tuitionBalance - payment);\n      @ also\n      @      public normal_behavior\n      @   \trequires !debit;\n      @   \told int penalty = (payment/100)*2;\n      @   \told int _payment = payment - penalty;\n      @   \trequires validPayment(_payment);\n      @   \trequires Integer.MIN_VALUE <= tuitionBalance - _payment;\n      @   \tassignable this.tuitionBalance;\n      @   \tensures tuitionBalance == \\old (tuitionBalance - _payment); @*/\n    public void pay(int payment, boolean debit) \n    {\n        if (debit) {\n            payTuitionWithDebitCard(payment);\n        } else {\n            payTuitionWithCreditCard(payment);\n        }\n    }\n\n    /*@      public exceptional_behavior\n      @   \trequires !(initialBalance <= maxSemesterCredits * costPerCredit + maxSemesterCredits * ((costPerCredit/100)*6))\n      @           || !(0 <= passedCredits && passedCredits <= totalCredits)\n      @           || !(0 <= semesterCredits && semesterCredits <= maxSemesterCredits);\n      @   \tsignals_only IllegalArgumentException;\n      @ also\n      @      public normal_behavior\n      @   \tassignable this.*;\n      @   \told int latePerCredit = (costPerCredit/100)*6;\n      @  \told int penalty = (payment/100)*2;\n      @   \told int _payment = payment - penalty;\n      @   \trequires 0 < payment; \n      @   \trequires passedCredits + semesterCredits <= totalCredits;\n      @   \trequires initialBalance <= maxSemesterCredits * costPerCredit + maxSemesterCredits * ((costPerCredit/100)*6);\n      @   \trequires 0 <= semesterCredits && semesterCredits <= maxSemesterCredits;\n      @   \trequires 0 <= passedCredits && passedCredits <= totalCredits;\n      @   \trequires lateRegistration ==> initialBalance + maxSemesterCredits * costPerCredit + maxSemesterCredits * latePerCredit <= Integer.MAX_VALUE;\n      @   \trequires !lateRegistration ==> initialBalance + maxSemesterCredits * costPerCredit <= Integer.MAX_VALUE;\n      @   \trequires debit ==> Integer.MIN_VALUE <= initialBalance - payment;\n      @   \trequires !debit ==> Integer.MIN_VALUE <= initialBalance - _payment;\n      @   \t{|\n      @ \t\trequires !lateRegistration && option && initialBalance <= 0;\n      @ \t\tensures this.tuitionBalance == initialBalance + enrollmentCredits * costPerCredit;\n      @ \t\tensures this.enrollmentCredits == semesterCredits;\n      @ \t\tensures this.passedCredits == passedCredits;\n      @ \talso\n      @ \t\trequires lateRegistration && option && initialBalance <= 0;\n      @ \t\tensures this.tuitionBalance == initialBalance + enrollmentCredits * costPerCredit + enrollmentCredits * latePerCredit;\n      @ \t\tensures this.enrollmentCredits == semesterCredits;\n      @ \t\tensures this.passedCredits == passedCredits;\n      @ \talso\n      @ \t\trequires debit && validPayment(payment) && !option;\n      @ \t\tensures this.tuitionBalance == initialBalance - payment;\t        \n      @ \talso\n      @ \t\trequires !debit && validPayment(_payment) && !option;\n      @ \t\tensures this.tuitionBalance == initialBalance - _payment;\n      @         |} @*/\n    public void enrollmentProcess(int passedCredits, int semesterCredits, int payment, int initialBalance, boolean lateRegistration, boolean debit, boolean option) \n     {\n        String familyName = getLastName();\n        String firstName = getFirstName();\n        setTuitionBalance(initialBalance);\n        setPassedCredits(passedCredits);\n        setEnrollmentCredits(semesterCredits);\n\tsetLateRegistration(lateRegistration);\n\n        if (option) {\n\t\tif (registrationPermission()) {\n\t\t\tenroll();\n                }\n\t} else {\n\t\tpay(payment, debit);\n\t}\n     }\n}',
  },
  {
    className: 'SwapInArray',
    testcase:
      'public class SwapInArray {\n        \n\tpublic void swap(int x, int y,  int array[]) {\n\t   int temp;     \n      temp = array[x];\n      array[x] = array[y];\n      array[y] = temp;\n   }\n}',
    groundTruth:
      'public class SwapInArray {\n        /*@ requires 0 <= x && x < array.length && 0 <= y && y < array.length; \n\t  @ assignable array[x], array[y]; \n\t  @ ensures \\old(array[x]) == array[y] && \\old(array[y]) == array[x];\n\t  @ ensures array.length == \\old(array.length); @*/\n\tpublic void swap(int x, int y,  int array[]) {\n\t  int temp;     \n          temp = array[x];\n          array[x] = array[y];\n          array[y] = temp;\n       }\n    }',
  },
  {
    className: 'Time',
    testcase:
      'public class Time {\n    private  int second;\n    private  int minute;\n    private  int hour;\n\n    public  Time() \n    {\n        hour = 23;\n        minute = 59;\n        second = 59;\n    }\n\n    public  Time(int h, int m, int s) \n    {\n        hour = h;\n        minute = m;\n        second = s;\n    }\n     \n    public void setSecond(int s) \n    {\n        if (s < 0 || 60 <= s) {\n            throw new IllegalArgumentException();\n        } else {\n            this.second = s;\n        }\n    } \n\n    \n    public void setMinute(int m) \n    {\n        if (m < 0 || 60 <= m) {\n            throw new IllegalArgumentException();\n        } else {\n            this.minute = m;\n        }\n    } \n\n    \n    public void setHour(int h) \n    {\n        if (h < 0 || 24 <= h) {\n            throw new IllegalArgumentException();\n        } else {\n            this.hour = h;\n        }\n    } \n\n    \n    public  Time getTime()\n    {\n\tTime t = new Time(this.hour, this.minute, this.second);\n\treturn t;\n    }\n\n    \n    public  int getSecond()\n    {\n        return second;\n    }\n\n    \n    public  int getMinute()\n    {\n        return minute;\n    }\n\n\n    \n    public  int getHour() \n    {\n        return hour;\n    }\n\n    \n    public  int convertToSeconds()\n    {\n        return (hour*60*60 + minute*60 + second);\n    }\n\n    public void decr()\n    {\n        if (isTimeZero())\n            return;\n        else {\n            second--;\n            if(second < 0) {\n                second = 59;\n                minute--;\n                if (minute < 0 ) { \n                    minute = 59; \n                    hour--;\n                }\n            }\n        }\n    }\n\n    public void timer()\n    {\n        \n        \n        while (!isTimeZero()) {\n            \n            \n            decr();\n        }\n    }\n\n    public void timer(int h, int m, int s)\n    {\n        setHour(h);\n        setMinute(m);\n        setSecond(s);\n\t\n        timer();\n    }\n\n    \n    public  boolean isTimeZero() \n    {\n        return (convertToSeconds() == 0);\n    }\n\n    \n    \n    public void reset()\n    {\n        second = 0;\n        minute = 0; \n        hour = 0;\n    }\n\n    \n    public  boolean later_than(Time start) \n    {\n        if (this.hour != start.hour) {\n            return this.hour > start.hour;\n        } else if (this.minute != start.minute) {\n            return this.minute > start.minute;\n        } else { \n            return this.second > start.second;\n        }\n    }\n\n    public boolean equals(Object o) \n    {\n        if (!(o instanceof Time)) {\n            return false;\n        }\n        Time t = (Time) o;\n        return this.hour == t.hour && this.minute == t.minute && this.second == t.second;\n    }\n\n    private  Time trustedDifference(Time start, Time stop) \n    {\n        Time diff = new Time();\n        int temp_second = stop.getSecond();\n        int temp_minute = stop.getMinute();\n        int temp_hour = stop.getHour();\n       \n        if (temp_second < start.getSecond()) {\n            --temp_minute;\n            temp_second += 60;\n        }\n\t\n        diff.second = temp_second - start.getSecond();\n\n        if (temp_minute < start.getMinute()) {\n            --temp_hour;\n            temp_minute += 60;\n        }\n\n        diff.minute = temp_minute - start.getMinute();\n        diff.hour = temp_hour - start.getHour();\n        return(diff);\n    }\n\n    public  Time difference(Time start, Time stop)\n    {\n        if (stop.later_than(start)) {\n                return trustedDifference(start, stop);\n        } else {\n                return trustedDifference(stop, start);\n        }\n    }\t\n   \n    public Time timeOptions(Time start, Time stop, int sel) {\n\tif (sel == 0) {\n\t\treset();\n\t} else if (sel == 1) {\n\t\ttimer(start.hour, start.minute, start.second);\n\t} else if (sel == 2) {\n\t\ttimer();\n\t} else if (sel == 3) {\n\t\tif (start.equals(stop)) {\n\t\t\tstart.reset();\n\t\t\treturn start.getTime();\n\t\t}\n\t} else {\n   \t\treturn difference(start, stop);\n\t}\n\treturn getTime();\n    }\n}',
    groundTruth:
      'public class Time {\n    private /*@ spec_public @*/ int second;\n    private /*@ spec_public @*/ int minute;\n    private /*@ spec_public @*/ int hour;\n\n    /*@ public invariant 0 <= second && second < 60;\n      public invariant 0 <= minute && minute < 60;\n      public invariant 0 <= hour && hour < 24; @*/\n\n    //@ ensures this.hour == 23;\n    //@ ensures this.minute == 59;\n    //@ ensures this.second == 59;\n    public /*@ pure @*/ Time() \n    {\n        hour = 23;\n        minute = 59;\n        second = 59;\n    }\n\n    //@ requires 0 <= h && h < 24;\n    //@ requires 0 <= m && m < 60;\n    //@ requires 0 <= s && s < 60;\n    //@ ensures this.hour == h;\n    //@ ensures this.minute == m;\n    //@ ensures this.second == s;\n    public /*@ pure @*/ Time(int h, int m, int s) \n    {\n        hour = h;\n        minute = m;\n        second = s;\n    }\n    /*@      public normal_behavior\n      @     \trequires 0 <= s && s < 60;\n      @     \tassignable this.second;\n      @     \tensures this.second == s;\n      @ also\n      @     public exceptional_behavior\n      @     \trequires s < 0 || 60 <= s;\n      @     \tassignable \\nothing;\n      @     \tsignals_only IllegalArgumentException; @*/ \n    public void setSecond(int s) \n    {\n        if (s < 0 || 60 <= s) {\n            throw new IllegalArgumentException();\n        } else {\n            this.second = s;\n        }\n    } \n\n    /*@     public normal_behavior\n      @     \trequires 0 <= m && m < 60;\n      @     \tassignable this.minute;\n      @     \tensures this.minute == m;\n      @ also\n      @     public exceptional_behavior\n      @      \trequires m < 0 || 60 <= m;\n      @     \tassignable \\nothing;\n      @     \tsignals_only IllegalArgumentException; @*/\n    public void setMinute(int m) \n    {\n        if (m < 0 || 60 <= m) {\n            throw new IllegalArgumentException();\n        } else {\n            this.minute = m;\n        }\n    } \n\n    /*@     public normal_behavior\n      @  \trequires 0 <= h && h < 24;\n      @\t  \tassignable this.hour;\n      @  \tensures this.hour == h;\n      @ also\n      @     public exceptional_behavior\n      @ \trequires h < 0 || 24 <= h;\n      @     \tassignable \\nothing;\n      @  \tsignals_only IllegalArgumentException; @*/\n    public void setHour(int h) \n    {\n        if (h < 0 || 24 <= h) {\n            throw new IllegalArgumentException();\n        } else {\n            this.hour = h;\n        }\n    } \n\n    //@ ensures this.equals(\\result) && this != \\result;\n    public /*@ pure @*/ Time getTime()\n    {\n\tTime t = new Time(this.hour, this.minute, this.second);\n\treturn t;\n    }\n\n    //@ ensures \\result == second;\n    public /*@ pure @*/ int getSecond()\n    {\n        return second;\n    }\n\n    //@ ensures \\result == minute;\n    public /*@ pure @*/ int getMinute()\n    {\n        return minute;\n    }\n\n\n    //@ ensures \\result == hour;\n    public /*@ pure @*/ int getHour() \n    {\n        return hour;\n    }\n\n    //@ ensures \\result == hour*60*60 + minute*60 + second;\n    public /*@ pure @*/ int convertToSeconds()\n    {\n        return (hour*60*60 + minute*60 + second);\n    }\n\n    //@ \trequires convertToSeconds() == 0;\n    //@   \tensures convertToSeconds() == 0;\n    //@ also\n    //@   \trequires convertToSeconds() != 0;\n    //@   \tassignable second, minute, hour;\n    //@   \tensures convertToSeconds() == \\old(convertToSeconds() - 1);\n    public void decr()\n    {\n        if (isTimeZero())\n            return;\n        else {\n            second--;\n            if(second < 0) {\n                second = 59;\n                minute--;\n                if (minute < 0 ) { \n                    minute = 59; \n                    hour--;\n                }\n            }\n        }\n    }\n\n    //@ assignable second, minute, hour;\n    //@ ensures convertToSeconds() == 0;\n    public void timer()\n    {\n        //@ ghost boolean flag = false;\n        //@ maintaining !isTimeZero() && flag ==> convertToSeconds() == \\old (convertToSeconds() - 1);\n        while (!isTimeZero()) {\n            //@ set flag = true;\n            // each time around this loop should take 1 second, ideally\n            decr();\n        }\n    }\n\n    \n    //@ requires 0 <= h && h < 24;\n    //@ requires 0 <= m && m < 60;\n    //@ requires 0 <= s && s < 60;\n    //@ assignable this.second, this.minute, this.hour;\n    //@ ensures convertToSeconds() == 0;\n    public void timer(int h, int m, int s)\n    {\n        setHour(h);\n        setMinute(m);\n        setSecond(s);\n\t//@ assert hour == h && minute == m && second == s;\n        timer();\n    }\n\n    //@ ensures \\result == (convertToSeconds() == 0);\n    public /*@ pure */ boolean isTimeZero() \n    {\n        return (convertToSeconds() == 0);\n    }\n\n    //@ assignable second, minute, hour;\n    //@ ensures second == 0 && minute == 0 && hour == 0;\n    public void reset()\n    {\n        second = 0;\n        minute = 0; \n        hour = 0;\n    }\n\n    /*@ ensures \\result == ((this.hour > start.hour) \n      @                   || (this.hour == start.hour && this.minute > start.minute) \n      @                   || (this.hour == start.hour && this.minute == start.minute && this.second > start.second)); @*/\n    public /*@ pure @*/ boolean later_than(Time start) \n    {\n        if (this.hour != start.hour) {\n            return this.hour > start.hour;\n        } else if (this.minute != start.minute) {\n            return this.minute > start.minute;\n        } else { \n            return this.second > start.second;\n        }\n    }\n\n    //@ also\n    //@    \trequires !(o instanceof Time);\n    //@    \tensures !\\result;\n    //@ also\n    //@    \trequires (o instanceof Time);\n    /*@    \tensures \\result <==> (this.hour == ((Time) o).hour)\n      @                               && (this.minute == ((Time) o).minute)\n      @                        \t      && (this.second == ((Time) o).second); @*/\n    public boolean equals(Object o) \n    {\n        if (!(o instanceof Time)) {\n            return false;\n        }\n        Time t = (Time) o;\n        return this.hour == t.hour && this.minute == t.minute && this.second == t.second;\n    }\n\n    //@ requires stop.later_than(start) || stop.equals(start);\t\t\n    //@ old int _stop_minutes = (stop.second < start.second) ? (stop.minute -1): stop.minute;\n    //@ old int diff_seconds = (stop.second < start.second) ? (stop.second + 60 - start.second) : (stop.second - start.second);\n    //@ old int _stop_hours = (_stop_minutes < start.minute) ? (stop.hour -1): stop.hour;\n    //@ old int diff_minutes = (_stop_minutes < start.minute) ? (_stop_minutes + 60 - start.minute) : (_stop_minutes - start.minute);\n    //@ old int diff_hours = _stop_hours - start.hour;\n    //@ ensures diff_hours == \\result.hour;\n    //@ ensures diff_minutes == \\result.minute;\n    //@ ensures diff_seconds == \\result.second;\n    private /*@ spec_public pure @*/ Time trustedDifference(Time start, Time stop) \n    {\n        Time diff = new Time();\n        int temp_second = stop.getSecond();\n        int temp_minute = stop.getMinute();\n        int temp_hour = stop.getHour();\n       \n        if (temp_second < start.getSecond()) {\n            --temp_minute;\n            temp_second += 60;\n        }\n\t\n        diff.second = temp_second - start.getSecond();\n\n        if (temp_minute < start.getMinute()) {\n            --temp_hour;\n            temp_minute += 60;\n        }\n\n        diff.minute = temp_minute - start.getMinute();\n        diff.hour = temp_hour - start.getHour();\n        return(diff);\n    }\n\n    //@    \trequires stop.later_than(start);\n    //@ \tensures \\result.equals(trustedDifference(start,stop));\n    //@ also\n    //@    \trequires start.later_than(stop) || stop.equals(start);\n    //@    \tensures \\result.equals(trustedDifference(stop,start));\n    public /*@ pure @*/ Time difference(Time start, Time stop)\n    {\n\tif (stop.later_than(start)) {\n            return trustedDifference(start, stop);\n\t} else {\n            return trustedDifference(stop, start);\n\t}\n    }\t\n\n    /*@ requires 0 <= sel && sel < 5;\n      @ {|\n      @\t\trequires 0 <= sel && sel <= 2;\n      @\t\tensures \\result.hour == 0 && \\result.minute == 0 && \\result.second == 0;\n      @\t\tensures  start == \\old (start);\n      @\t\tensures  stop == \\old (stop);\n      @ also\n      @\t\trequires sel == 3 && !start.equals(stop);\n      @\t\tensures \\result.hour == \\old (hour) && \\result.minute == \\old (minute) && \\result.second == \\old (second);\n      @\talso\n      @\t\trequires sel == 3 && start.equals(stop);\n      @\t\tensures  \\result.hour == 0 && \\result.minute == 0 && \\result.second == 0;\n      @\t\tensures  start.hour == 0 && start.minute == 0 && start.second == 0;\n      @\t\tensures  stop == \\old (stop);\n      @\talso\n      @\t\trequires sel == 4;\n      @\t\tassignable \\nothing;\n      @\t\tensures \\result.equals(difference(start, stop));\n      @\t\tensures  start == \\old (start);\n      @\t\tensures  stop == \\old (stop);\n      @ |}\n    @*/     \n    public Time timeOptions(Time start, Time stop, int sel) {\n\tif (sel == 0) {\n\t\treset();\n\t} else if (sel == 1) {\n\t\ttimer(start.hour, start.minute, start.second);\n\t} else if (sel == 2) {\n\t\ttimer();\n\t} else if (sel == 3) {\n\t\tif (start.equals(stop)) {\n\t\t\tstart.reset();\n\t\t\treturn start.getTime();\n\t\t}\n\t} else {\n   \t\treturn difference(start, stop);\n\t}\n\treturn getTime();\n    }\n}',
  },
  {
    className: 'TransposeMatrix',
    testcase:
      'public class TransposeMatrix {\n\n       public int[][] transposeMat(int[][] matrix)\n       {\n          int m, n, p, q;\n          m = matrix.length;\n          n = matrix[0].length;\n          int[][] transpose = new int[n][m];\n\n          for (int c = 0; c < n; c++) {\n\n              for (int d = 0; d < m; d++) {\n                  transpose[c][d] = matrix[d][c];\n              }\n          }\n          return transpose;\n       }\n}',
    groundTruth:
      'public class TransposeMatrix {\n       //@ requires 0 < matrix.length && matrix.length <= Integer.MAX_VALUE;\n       //@ requires 0 < matrix[0].length && matrix[0].length <= Integer.MAX_VALUE;\n       //@ requires (\\forall int k; 0 <= k && k < matrix.length; matrix[k] != null);\n       //@ requires (\\forall int k; 0 <= k && k < matrix.length; matrix[0].length == matrix[k].length);\n       //@ ensures (\\forall int i; 0<= i && i < matrix[0].length; (\\forall int j; 0 <= j && j < matrix.length ; \\result[i][j] == matrix[j][i]));\n       //@ ensures matrix.length == \\result[0].length;\n       //@ ensures matrix[0].length == \\result.length; \n       public int[][] transposeMat(int[][] matrix)\n       {\n          int m, n, p, q;\n          m = matrix.length;\n          n = matrix[0].length;\n          int[][] transpose = new int[n][m];\n\n          //@ assume \\forall int i; 0 <= i && i < n; transpose[i] != null && transpose[i].length == m;\n          //@ assume \\forall int e; 0 <= e && e < n; \\forall int k; 0 <= k && k < n; (e != k ==> transpose[e] != transpose[k]);\n          //@ assume \\forall int e; 0<= e && e < n; (\\forall int k; 0 <= k && k < m; transpose[e] != matrix[k]);\n\n          //@ maintaining 0 <= c && c <= n;\n          //@ maintaining \\forall int i; 0 <= i && i < c; (\\forall int j; 0 <= j && j < m ; transpose[i][j] == matrix[j][i]);\n          //@ decreases n - c;\n          for (int c = 0; c < n; c++) {\n              //@ maintaining 0 <= d && d <= m;\n              //@ maintaining (\\forall int j; 0 <= j && j < d; transpose[c][j] == matrix[j][c]);\n              //@ decreases m - d;\n              for (int d = 0; d < m; d++) {\n                  transpose[c][d] = matrix[d][c];\n              }\n          }\n          return transpose;\n       }\n}',
  },
];
